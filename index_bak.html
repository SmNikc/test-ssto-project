<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Модуль ТЕСТ ССТО - Система управления тестированием ГМСКЦ</title>
    
    <!-- OpenLayers для морских карт -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v7.3.0/ol.css">
    <script src="https://cdn.jsdelivr.net/npm/ol@v7.3.0/dist/ol.js"></script>
    
    <style>
        /* ============================================
           БАЗОВЫЕ СТИЛИ СИСТЕМЫ ССТО
           ============================================ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
            overflow-x: hidden;
        }
        
        /* ============================================
           ШАПКА СИСТЕМЫ
           ============================================ */
        .header {
            background: rgba(255, 255, 255, 0.95);
            box-shadow: 0 2px 20px rgba(0,0,0,0.1);
            padding: 20px 0;
            position: sticky;
            top: 0;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }
        
        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .logo-icon {
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .logo-text h1 {
            font-size: 24px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 2px;
        }
        
        .logo-text p {
            font-size: 12px;
            color: #666;
        }
        
        .user-info {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        .user-badge {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 16px;
            background: #f8f9fa;
            border-radius: 8px;
            transition: all 0.3s;
        }
        
        .user-badge:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        .user-avatar {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }
        
        .auto-mode-indicator {
            padding: 8px 16px;
            background: #f8f9fa;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .auto-mode-indicator:hover {
            transform: scale(1.05);
        }
        
        /* ============================================
           НАВИГАЦИЯ
           ============================================ */
        .navigation {
            background: white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            position: sticky;
            top: 90px;
            z-index: 999;
        }
        
        .nav-tabs {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 20px;
            display: flex;
            gap: 5px;
            overflow-x: auto;
        }
        
        .nav-tabs::-webkit-scrollbar {
            height: 3px;
        }
        
        .nav-tabs::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        
        .nav-tabs::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 3px;
        }
        
        .tab {
            padding: 15px 25px;
            background: transparent;
            border: none;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #666;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
            position: relative;
        }
        
        .tab:hover {
            background: #f8f9fa;
            color: #333;
        }
        
        .tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
            background: #f8f9fa;
        }
        
        .tab.active::after {
            content: '';
            position: absolute;
            bottom: -3px;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #667eea, #764ba2);
            animation: slideIn 0.3s;
        }
        
        @keyframes slideIn {
            from { transform: scaleX(0); }
            to { transform: scaleX(1); }
        }
        
        /* ============================================
           ОСНОВНОЙ КОНТЕЙНЕР
           ============================================ */
        .main-container {
            max-width: 1400px;
            margin: 30px auto;
            padding: 0 20px;
        }
        
        .content {
            display: none;
            animation: fadeIn 0.3s;
        }
        
        .content.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { 
                opacity: 0; 
                transform: translateY(10px); 
            }
            to { 
                opacity: 1; 
                transform: translateY(0); 
            }
        }
        
        /* ============================================
           DASHBOARD СЕТКА
           ============================================ */
        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: white;
            border-radius: 16px;
            padding: 25px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }
        
        .stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transform: scaleX(0);
            transition: transform 0.3s;
        }
        
        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 30px rgba(0,0,0,0.12);
        }
        
        .stat-card:hover::before {
            transform: scaleX(1);
        }
        
        .stat-card.primary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }
        
        .stat-card.success {
            background: linear-gradient(135deg, #48bb78, #38a169);
            color: white;
        }
        
        .stat-card.warning {
            background: linear-gradient(135deg, #ed8936, #dd6b20);
            color: white;
        }
        
        .stat-card.info {
            background: linear-gradient(135deg, #4299e1, #3182ce);
            color: white;
        }
        
        .stat-card.danger {
            background: linear-gradient(135deg, #f56565, #e53e3e);
            color: white;
        }
        
        .stat-value {
            font-size: 36px;
            font-weight: bold;
            margin-bottom: 8px;
            animation: countUp 1s;
        }
        
        @keyframes countUp {
            from { opacity: 0; transform: scale(0.5); }
            to { opacity: 1; transform: scale(1); }
        }
        
        .stat-label {
            font-size: 14px;
            opacity: 0.9;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .stat-icon {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 40px;
            opacity: 0.2;
        }
        
        /* ============================================
           КАРТОЧКИ И ФОРМЫ
           ============================================ */
        .card {
            background: white;
            border-radius: 16px;
            padding: 30px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            margin-bottom: 30px;
            transition: all 0.3s;
        }
        
        .card:hover {
            box-shadow: 0 6px 25px rgba(0,0,0,0.1);
        }
        
        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid #f0f0f0;
        }
        
        .card-title {
            font-size: 20px;
            font-weight: 600;
            color: #333;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .card-actions {
            display: flex;
            gap: 10px;
        }
        
        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #555;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .form-group label .required {
            color: #e53e3e;
            margin-left: 2px;
        }
        
        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            font-size: 14px;
            transition: all 0.3s;
            background: white;
        }
        
        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
            transform: translateY(-2px);
        }
        
        .form-group input:invalid {
            border-color: #f56565;
        }
        
        .form-group textarea {
            resize: vertical;
            min-height: 100px;
        }
        
        /* ============================================
           СПЕЦИАЛЬНОЕ ПОЛЕ НОМЕРА ТЕРМИНАЛА
           ============================================ */
        .terminal-input-group {
            position: relative;
        }
        
        .terminal-input-group input {
            font-size: 20px;
            font-weight: bold;
            color: #0066cc;
            border: 3px solid #0066cc;
            background: linear-gradient(135deg, #f0f8ff, #e6f4ff);
            padding: 15px;
            text-align: center;
            letter-spacing: 2px;
        }
        
        .terminal-input-group input:focus {
            box-shadow: 0 0 0 5px rgba(0, 102, 204, 0.2);
            animation: glow 1s infinite alternate;
        }
        
        @keyframes glow {
            from { box-shadow: 0 0 0 5px rgba(0, 102, 204, 0.2); }
            to { box-shadow: 0 0 0 8px rgba(0, 102, 204, 0.1); }
        }
        
        .terminal-input-group .input-hint {
            position: absolute;
            top: -20px;
            right: 0;
            font-size: 11px;
            color: #666;
            background: white;
            padding: 2px 8px;
            border-radius: 4px;
        }
        
        .terminal-type-switch {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .terminal-type-btn {
            flex: 1;
            padding: 12px;
            border: 2px solid #e2e8f0;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 13px;
        }
        
        .terminal-type-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        .terminal-type-btn.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border-color: #667eea;
            transform: scale(1.05);
        }
        
        .terminal-type-btn.active.inmarsat {
            background: linear-gradient(135deg, #48bb78, #38a169);
            border-color: #48bb78;
        }
        
        .terminal-type-btn.active.iridium {
            background: linear-gradient(135deg, #4299e1, #3182ce);
            border-color: #4299e1;
        }
		</div>

    <!-- Модальные окна -->
    <!-- Модальное окно добавления судна -->
    <div id="vesselModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="vesselModalTitle">Добавить судно</h2>
                <span class="modal-close" onclick="app.closeModal('vesselModal')">&times;</span>
            </div>
            <div class="modal-body">
                <form id="vesselForm">
                    <div class="form-group">
                        <label>Название судна *</label>
                        <input type="text" id="vesselName" required>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label>IMO *</label>
                            <input type="text" id="vesselIMO" pattern="[0-9]{7}" required>
                        </div>
                        <div class="form-group">
                            <label>MMSI *</label>
                            <input type="text" id="vesselMMSI" pattern="[0-9]{9}" required>
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label>Тип судна</label>
                            <select id="vesselType">
                                <option value="cargo">Грузовое</option>
                                <option value="tanker">Танкер</option>
                                <option value="container">Контейнеровоз</option>
                                <option value="bulk">Балкер</option>
                                <option value="passenger">Пассажирское</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Флаг</label>
                            <select id="vesselFlag">
                                <option value="RU">Россия</option>
                                <option value="PA">Панама</option>
                                <option value="LR">Либерия</option>
                                <option value="MT">Мальта</option>
                            </select>
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label>Длина (м)</label>
                            <input type="number" id="vesselLength" min="0" step="0.1">
                        </div>
                        <div class="form-group">
                            <label>Ширина (м)</label>
                            <input type="number" id="vesselWidth" min="0" step="0.1">
                        </div>
                        <div class="form-group">
                            <label>Осадка (м)</label>
                            <input type="number" id="vesselDraft" min="0" step="0.1">
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Порт назначения</label>
                        <input type="text" id="vesselDestination">
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label>ETA</label>
                            <input type="datetime-local" id="vesselETA">
                        </div>
                        <div class="form-group">
                            <label>ETD</label>
                            <input type="datetime-local" id="vesselETD">
                        </div>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="app.closeModal('vesselModal')">
                    Отмена
                </button>
                <button class="btn btn-primary" onclick="app.saveVessel()">
                    Сохранить
                </button>
            </div>
        </div>
    </div>

    <!-- Модальное окно терминала -->
    <div id="terminalModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Настройки терминала ССТО</h2>
                <span class="modal-close" onclick="app.closeModal('terminalModal')">&times;</span>
            </div>
            <div class="modal-body">
                <form id="terminalForm">
                    <div class="form-group">
                        <label>Номер терминала *</label>
                        <input type="text" id="modalTerminalNumber" required>
                    </div>
                    <div class="form-group">
                        <label>Название терминала</label>
                        <input type="text" id="modalTerminalName">
                    </div>
                    <div class="form-group">
                        <label>Порт</label>
                        <input type="text" id="modalTerminalPort">
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label>Широта</label>
                            <input type="number" id="modalTerminalLat" step="0.000001">
                        </div>
                        <div class="form-group">
                            <label>Долгота</label>
                            <input type="number" id="modalTerminalLon" step="0.000001">
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Максимальная осадка (м)</label>
                        <input type="number" id="modalTerminalMaxDraft" min="0" step="0.1">
                    </div>
                    <div class="form-group">
                        <label>Количество причалов</label>
                        <input type="number" id="modalTerminalBerths" min="1">
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="app.closeModal('terminalModal')">
                    Отмена
                </button>
                <button class="btn btn-primary" onclick="app.saveTerminal()">
                    Сохранить
                </button>
            </div>
        </div>
    </div>

    <!-- Модальное окно истории -->
    <div id="historyModal" class="modal">
        <div class="modal-content modal-large">
            <div class="modal-header">
                <h2>История перемещений судна</h2>
                <span class="modal-close" onclick="app.closeModal('historyModal')">&times;</span>
            </div>
            <div class="modal-body">
                <div id="historyContent">
                    <!-- Динамически заполняется -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-info" onclick="app.exportHistory()">
                    Экспорт истории
                </button>
                <button class="btn btn-secondary" onclick="app.closeModal('historyModal')">
                    Закрыть
                </button>
            </div>
        </div>
    </div>

    <!-- JavaScript -->
    <script>
    // ===== ГЛАВНЫЙ МОДУЛЬ ПРИЛОЖЕНИЯ =====
    const app = {
        // Инициализация
        version: '2.0.0',
        currentTab: 'vessels',
        currentTerminal: null,
        vessels: [],
        terminals: [],
        alerts: [],
        events: [],
        
        // Компоненты системы
        autoConfirmManager: null,
        emailProcessor: null,
        poiskMoreIntegration: null,
        vesselDB: null,
        map: null,

        // ===== ИНИЦИАЛИЗАЦИЯ =====
        init() {
            console.log(`ССТО Модуль v${this.version} - Инициализация`);
            
            // Загрузка данных из localStorage
            this.loadData();
            
            // Инициализация компонентов
            this.initComponents();
            
            // Установка обработчиков событий
            this.setupEventHandlers();
            
            // Инициализация горячих клавиш
            this.setupHotkeys();
            
            // Запуск автообновления
            this.startAutoUpdate();
            
            // Проверка терминала
            this.checkTerminal();
            
            console.log('Инициализация завершена');
        },

        // Загрузка данных
        loadData() {
            try {
                // Загрузка судов
                const storedVessels = localStorage.getItem('ssto_vessels');
                if (storedVessels) {
                    this.vessels = JSON.parse(storedVessels);
                }
                
                // Загрузка терминалов
                const storedTerminals = localStorage.getItem('ssto_terminals');
                if (storedTerminals) {
                    this.terminals = JSON.parse(storedTerminals);
                }
                
                // Загрузка текущего терминала
                const storedTerminal = localStorage.getItem('ssto_current_terminal');
                if (storedTerminal) {
                    this.currentTerminal = JSON.parse(storedTerminal);
                    this.updateTerminalDisplay();
                }
                
                // Загрузка событий
                const storedEvents = localStorage.getItem('ssto_events');
                if (storedEvents) {
                    this.events = JSON.parse(storedEvents);
                }
                
                console.log('Данные загружены:', {
                    vessels: this.vessels.length,
                    terminals: this.terminals.length,
                    events: this.events.length
                });
            } catch (error) {
                console.error('Ошибка загрузки данных:', error);
            }
        },

        // Сохранение данных
        saveData() {
            try {
                localStorage.setItem('ssto_vessels', JSON.stringify(this.vessels));
                localStorage.setItem('ssto_terminals', JSON.stringify(this.terminals));
                localStorage.setItem('ssto_events', JSON.stringify(this.events));
                
                if (this.currentTerminal) {
                    localStorage.setItem('ssto_current_terminal', JSON.stringify(this.currentTerminal));
                }
                
                console.log('Данные сохранены');
            } catch (error) {
                console.error('Ошибка сохранения данных:', error);
            }
        },

        // Инициализация компонентов
        initComponents() {
            // Инициализация AutoConfirmationManager
            this.autoConfirmManager = new AutoConfirmationManager();
            
            // Инициализация EmailProcessor
            this.emailProcessor = new EmailProcessor();
            
            // Инициализация PoiskMoreIntegration
            this.poiskMoreIntegration = new PoiskMoreIntegration();
            
            // Инициализация VesselDB
            this.vesselDB = new VesselDB();
            
            // Инициализация карты
            this.initMap();
            
            console.log('Компоненты инициализированы');
        },

        // Установка обработчиков событий
        setupEventHandlers() {
            // Обработчик изменения размера окна
            window.addEventListener('resize', () => {
                if (this.map) {
                    this.map.updateSize();
                }
            });
            
            // Обработчик закрытия/обновления страницы
            window.addEventListener('beforeunload', () => {
                this.saveData();
            });
            
            // Автосохранение каждые 30 секунд
            setInterval(() => {
                this.saveData();
            }, 30000);
        },

        // Установка горячих клавиш
        setupHotkeys() {
            document.addEventListener('keydown', (e) => {
                // Alt+N - Новое судно
                if (e.altKey && e.key === 'n') {
                    e.preventDefault();
                    this.addNewVessel();
                }
                
                // Alt+R - Обновить
                if (e.altKey && e.key === 'r') {
                    e.preventDefault();
                    this.refreshVesselList();
                }
                
                // Alt+M - Карта
                if (e.altKey && e.key === 'm') {
                    e.preventDefault();
                    this.switchTab('map');
                }
                
                // Escape - Закрыть модальное окно
                if (e.key === 'Escape') {
                    this.closeAllModals();
                }
            });
        },

        // Запуск автообновления
        startAutoUpdate() {
            // Обновление статистики каждые 5 секунд
            setInterval(() => {
                this.updateStatistics();
            }, 5000);
            
            // Обновление времени синхронизации
            setInterval(() => {
                this.updateSyncTime();
            }, 1000);
        }
</div>

    <!-- Модальные окна -->
    <!-- Модальное окно добавления судна -->
    <div id="vesselModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="vesselModalTitle">Добавить судно</h2>
                <span class="modal-close" onclick="app.closeModal('vesselModal')">&times;</span>
            </div>
            <div class="modal-body">
                <form id="vesselForm">
                    <div class="form-group">
                        <label>Название судна *</label>
                        <input type="text" id="vesselName" required>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label>IMO *</label>
                            <input type="text" id="vesselIMO" pattern="[0-9]{7}" required>
                        </div>
                        <div class="form-group">
                            <label>MMSI *</label>
                            <input type="text" id="vesselMMSI" pattern="[0-9]{9}" required>
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label>Тип судна</label>
                            <select id="vesselType">
                                <option value="cargo">Грузовое</option>
                                <option value="tanker">Танкер</option>
                                <option value="container">Контейнеровоз</option>
                                <option value="bulk">Балкер</option>
                                <option value="passenger">Пассажирское</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Флаг</label>
                            <select id="vesselFlag">
                                <option value="RU">Россия</option>
                                <option value="PA">Панама</option>
                                <option value="LR">Либерия</option>
                                <option value="MT">Мальта</option>
                            </select>
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label>Длина (м)</label>
                            <input type="number" id="vesselLength" min="0" step="0.1">
                        </div>
                        <div class="form-group">
                            <label>Ширина (м)</label>
                            <input type="number" id="vesselWidth" min="0" step="0.1">
                        </div>
                        <div class="form-group">
                            <label>Осадка (м)</label>
                            <input type="number" id="vesselDraft" min="0" step="0.1">
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Порт назначения</label>
                        <input type="text" id="vesselDestination">
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label>ETA</label>
                            <input type="datetime-local" id="vesselETA">
                        </div>
                        <div class="form-group">
                            <label>ETD</label>
                            <input type="datetime-local" id="vesselETD">
                        </div>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="app.closeModal('vesselModal')">
                    Отмена
                </button>
                <button class="btn btn-primary" onclick="app.saveVessel()">
                    Сохранить
                </button>
            </div>
        </div>
    </div>

    <!-- Модальное окно терминала -->
    <div id="terminalModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Настройки терминала ССТО</h2>
                <span class="modal-close" onclick="app.closeModal('terminalModal')">&times;</span>
            </div>
            <div class="modal-body">
                <form id="terminalForm">
                    <div class="form-group">
                        <label>Номер терминала *</label>
                        <input type="text" id="modalTerminalNumber" required>
                    </div>
                    <div class="form-group">
                        <label>Название терминала</label>
                        <input type="text" id="modalTerminalName">
                    </div>
                    <div class="form-group">
                        <label>Порт</label>
                        <input type="text" id="modalTerminalPort">
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label>Широта</label>
                            <input type="number" id="modalTerminalLat" step="0.000001">
                        </div>
                        <div class="form-group">
                            <label>Долгота</label>
                            <input type="number" id="modalTerminalLon" step="0.000001">
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Максимальная осадка (м)</label>
                        <input type="number" id="modalTerminalMaxDraft" min="0" step="0.1">
                    </div>
                    <div class="form-group">
                        <label>Количество причалов</label>
                        <input type="number" id="modalTerminalBerths" min="1">
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="app.closeModal('terminalModal')">
                    Отмена
                </button>
                <button class="btn btn-primary" onclick="app.saveTerminal()">
                    Сохранить
                </button>
            </div>
        </div>
    </div>

    <!-- Модальное окно истории -->
    <div id="historyModal" class="modal">
        <div class="modal-content modal-large">
            <div class="modal-header">
                <h2>История перемещений судна</h2>
                <span class="modal-close" onclick="app.closeModal('historyModal')">&times;</span>
            </div>
            <div class="modal-body">
                <div id="historyContent">
                    <!-- Динамически заполняется -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-info" onclick="app.exportHistory()">
                    Экспорт истории
                </button>
                <button class="btn btn-secondary" onclick="app.closeModal('historyModal')">
                    Закрыть
                </button>
            </div>
        </div>
    </div>

    <!-- JavaScript -->
    <script>
    // ===== ГЛАВНЫЙ МОДУЛЬ ПРИЛОЖЕНИЯ =====
    const app = {
        // Инициализация
        version: '2.0.0',
        currentTab: 'vessels',
        currentTerminal: null,
        vessels: [],
        terminals: [],
        alerts: [],
        events: [],
        
        // Компоненты системы
        autoConfirmManager: null,
        emailProcessor: null,
        poiskMoreIntegration: null,
        vesselDB: null,
        map: null,

        // ===== ИНИЦИАЛИЗАЦИЯ =====
        init() {
            console.log(`ССТО Модуль v${this.version} - Инициализация`);
            
            // Загрузка данных из localStorage
            this.loadData();
            
            // Инициализация компонентов
            this.initComponents();
            
            // Установка обработчиков событий
            this.setupEventHandlers();
            
            // Инициализация горячих клавиш
            this.setupHotkeys();
            
            // Запуск автообновления
            this.startAutoUpdate();
            
            // Проверка терминала
            this.checkTerminal();
            
            console.log('Инициализация завершена');
        },

        // Загрузка данных
        loadData() {
            try {
                // Загрузка судов
                const storedVessels = localStorage.getItem('ssto_vessels');
                if (storedVessels) {
                    this.vessels = JSON.parse(storedVessels);
                }
                
                // Загрузка терминалов
                const storedTerminals = localStorage.getItem('ssto_terminals');
                if (storedTerminals) {
                    this.terminals = JSON.parse(storedTerminals);
                }
                
                // Загрузка текущего терминала
                const storedTerminal = localStorage.getItem('ssto_current_terminal');
                if (storedTerminal) {
                    this.currentTerminal = JSON.parse(storedTerminal);
                    this.updateTerminalDisplay();
                }
                
                // Загрузка событий
                const storedEvents = localStorage.getItem('ssto_events');
                if (storedEvents) {
                    this.events = JSON.parse(storedEvents);
                }
                
                console.log('Данные загружены:', {
                    vessels: this.vessels.length,
                    terminals: this.terminals.length,
                    events: this.events.length
                });
            } catch (error) {
                console.error('Ошибка загрузки данных:', error);
            }
        },

        // Сохранение данных
        saveData() {
            try {
                localStorage.setItem('ssto_vessels', JSON.stringify(this.vessels));
                localStorage.setItem('ssto_terminals', JSON.stringify(this.terminals));
                localStorage.setItem('ssto_events', JSON.stringify(this.events));
                
                if (this.currentTerminal) {
                    localStorage.setItem('ssto_current_terminal', JSON.stringify(this.currentTerminal));
                }
                
                console.log('Данные сохранены');
            } catch (error) {
                console.error('Ошибка сохранения данных:', error);
            }
        },

        // Инициализация компонентов
        initComponents() {
            // Инициализация AutoConfirmationManager
            this.autoConfirmManager = new AutoConfirmationManager();
            
            // Инициализация EmailProcessor
            this.emailProcessor = new EmailProcessor();
            
            // Инициализация PoiskMoreIntegration
            this.poiskMoreIntegration = new PoiskMoreIntegration();
            
            // Инициализация VesselDB
            this.vesselDB = new VesselDB();
            
            // Инициализация карты
            this.initMap();
            
            console.log('Компоненты инициализированы');
        },

        // Установка обработчиков событий
        setupEventHandlers() {
            // Обработчик изменения размера окна
            window.addEventListener('resize', () => {
                if (this.map) {
                    this.map.updateSize();
                }
            });
            
            // Обработчик закрытия/обновления страницы
            window.addEventListener('beforeunload', () => {
                this.saveData();
            });
            
            // Автосохранение каждые 30 секунд
            setInterval(() => {
                this.saveData();
            }, 30000);
        },

        // Установка горячих клавиш
        setupHotkeys() {
            document.addEventListener('keydown', (e) => {
                // Alt+N - Новое судно
                if (e.altKey && e.key === 'n') {
                    e.preventDefault();
                    this.addNewVessel();
                }
                
                // Alt+R - Обновить
                if (e.altKey && e.key === 'r') {
                    e.preventDefault();
                    this.refreshVesselList();
                }
                
                // Alt+M - Карта
                if (e.altKey && e.key === 'm') {
                    e.preventDefault();
                    this.switchTab('map');
                }
                
                // Escape - Закрыть модальное окно
                if (e.key === 'Escape') {
                    this.closeAllModals();
                }
            });
        },

        // Запуск автообновления
        startAutoUpdate() {
            // Обновление статистики каждые 5 секунд
            setInterval(() => {
                this.updateStatistics();
            }, 5000);
            
            // Обновление времени синхронизации
            setInterval(() => {
                this.updateSyncTime();
            }, 1000);
        }
</div>

    <!-- Модальные окна -->
    <!-- Модальное окно добавления судна -->
    <div id="vesselModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="vesselModalTitle">Добавить судно</h2>
                <span class="modal-close" onclick="app.closeModal('vesselModal')">&times;</span>
            </div>
            <div class="modal-body">
                <form id="vesselForm">
                    <div class="form-group">
                        <label>Название судна *</label>
                        <input type="text" id="vesselName" required>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label>IMO *</label>
                            <input type="text" id="vesselIMO" pattern="[0-9]{7}" required>
                        </div>
                        <div class="form-group">
                            <label>MMSI *</label>
                            <input type="text" id="vesselMMSI" pattern="[0-9]{9}" required>
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label>Тип судна</label>
                            <select id="vesselType">
                                <option value="cargo">Грузовое</option>
                                <option value="tanker">Танкер</option>
                                <option value="container">Контейнеровоз</option>
                                <option value="bulk">Балкер</option>
                                <option value="passenger">Пассажирское</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Флаг</label>
                            <select id="vesselFlag">
                                <option value="RU">Россия</option>
                                <option value="PA">Панама</option>
                                <option value="LR">Либерия</option>
                                <option value="MT">Мальта</option>
                            </select>
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label>Длина (м)</label>
                            <input type="number" id="vesselLength" min="0" step="0.1">
                        </div>
                        <div class="form-group">
                            <label>Ширина (м)</label>
                            <input type="number" id="vesselWidth" min="0" step="0.1">
                        </div>
                        <div class="form-group">
                            <label>Осадка (м)</label>
                            <input type="number" id="vesselDraft" min="0" step="0.1">
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Порт назначения</label>
                        <input type="text" id="vesselDestination">
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label>ETA</label>
                            <input type="datetime-local" id="vesselETA">
                        </div>
                        <div class="form-group">
                            <label>ETD</label>
                            <input type="datetime-local" id="vesselETD">
                        </div>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="app.closeModal('vesselModal')">
                    Отмена
                </button>
                <button class="btn btn-primary" onclick="app.saveVessel()">
                    Сохранить
                </button>
            </div>
        </div>
    </div>

    <!-- Модальное окно терминала -->
    <div id="terminalModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Настройки терминала ССТО</h2>
                <span class="modal-close" onclick="app.closeModal('terminalModal')">&times;</span>
            </div>
            <div class="modal-body">
                <form id="terminalForm">
                    <div class="form-group">
                        <label>Номер терминала *</label>
                        <input type="text" id="modalTerminalNumber" required>
                    </div>
                    <div class="form-group">
                        <label>Название терминала</label>
                        <input type="text" id="modalTerminalName">
                    </div>
                    <div class="form-group">
                        <label>Порт</label>
                        <input type="text" id="modalTerminalPort">
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label>Широта</label>
                            <input type="number" id="modalTerminalLat" step="0.000001">
                        </div>
                        <div class="form-group">
                            <label>Долгота</label>
                            <input type="number" id="modalTerminalLon" step="0.000001">
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Максимальная осадка (м)</label>
                        <input type="number" id="modalTerminalMaxDraft" min="0" step="0.1">
                    </div>
                    <div class="form-group">
                        <label>Количество причалов</label>
                        <input type="number" id="modalTerminalBerths" min="1">
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="app.closeModal('terminalModal')">
                    Отмена
                </button>
                <button class="btn btn-primary" onclick="app.saveTerminal()">
                    Сохранить
                </button>
            </div>
        </div>
    </div>

    <!-- Модальное окно истории -->
    <div id="historyModal" class="modal">
        <div class="modal-content modal-large">
            <div class="modal-header">
                <h2>История перемещений судна</h2>
                <span class="modal-close" onclick="app.closeModal('historyModal')">&times;</span>
            </div>
            <div class="modal-body">
                <div id="historyContent">
                    <!-- Динамически заполняется -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-info" onclick="app.exportHistory()">
                    Экспорт истории
                </button>
                <button class="btn btn-secondary" onclick="app.closeModal('historyModal')">
                    Закрыть
                </button>
            </div>
        </div>
    </div>

    <!-- JavaScript -->
    <script>
    // ===== ГЛАВНЫЙ МОДУЛЬ ПРИЛОЖЕНИЯ =====
    const app = {
        // Инициализация
        version: '2.0.0',
        currentTab: 'vessels',
        currentTerminal: null,
        vessels: [],
        terminals: [],
        alerts: [],
        events: [],
        
        // Компоненты системы
        autoConfirmManager: null,
        emailProcessor: null,
        poiskMoreIntegration: null,
        vesselDB: null,
        map: null,

        // ===== ИНИЦИАЛИЗАЦИЯ =====
        init() {
            console.log(`ССТО Модуль v${this.version} - Инициализация`);
            
            // Загрузка данных из localStorage
            this.loadData();
            
            // Инициализация компонентов
            this.initComponents();
            
            // Установка обработчиков событий
            this.setupEventHandlers();
            
            // Инициализация горячих клавиш
            this.setupHotkeys();
            
            // Запуск автообновления
            this.startAutoUpdate();
            
            // Проверка терминала
            this.checkTerminal();
            
            console.log('Инициализация завершена');
        },

        // Загрузка данных
        loadData() {
            try {
                // Загрузка судов
                const storedVessels = localStorage.getItem('ssto_vessels');
                if (storedVessels) {
                    this.vessels = JSON.parse(storedVessels);
                }
                
                // Загрузка терминалов
                const storedTerminals = localStorage.getItem('ssto_terminals');
                if (storedTerminals) {
                    this.terminals = JSON.parse(storedTerminals);
                }
                
                // Загрузка текущего терминала
                const storedTerminal = localStorage.getItem('ssto_current_terminal');
                if (storedTerminal) {
                    this.currentTerminal = JSON.parse(storedTerminal);
                    this.updateTerminalDisplay();
                }
                
                // Загрузка событий
                const storedEvents = localStorage.getItem('ssto_events');
                if (storedEvents) {
                    this.events = JSON.parse(storedEvents);
                }
                
                console.log('Данные загружены:', {
                    vessels: this.vessels.length,
                    terminals: this.terminals.length,
                    events: this.events.length
                });
            } catch (error) {
                console.error('Ошибка загрузки данных:', error);
            }
        },

        // Сохранение данных
        saveData() {
            try {
                localStorage.setItem('ssto_vessels', JSON.stringify(this.vessels));
                localStorage.setItem('ssto_terminals', JSON.stringify(this.terminals));
                localStorage.setItem('ssto_events', JSON.stringify(this.events));
                
                if (this.currentTerminal) {
                    localStorage.setItem('ssto_current_terminal', JSON.stringify(this.currentTerminal));
                }
                
                console.log('Данные сохранены');
            } catch (error) {
                console.error('Ошибка сохранения данных:', error);
            }
        },

        // Инициализация компонентов
        initComponents() {
            // Инициализация AutoConfirmationManager
            this.autoConfirmManager = new AutoConfirmationManager();
            
            // Инициализация EmailProcessor
            this.emailProcessor = new EmailProcessor();
            
            // Инициализация PoiskMoreIntegration
            this.poiskMoreIntegration = new PoiskMoreIntegration();
            
            // Инициализация VesselDB
            this.vesselDB = new VesselDB();
            
            // Инициализация карты
            this.initMap();
            
            console.log('Компоненты инициализированы');
        },

        // Установка обработчиков событий
        setupEventHandlers() {
            // Обработчик изменения размера окна
            window.addEventListener('resize', () => {
                if (this.map) {
                    this.map.updateSize();
                }
            });
            
            // Обработчик закрытия/обновления страницы
            window.addEventListener('beforeunload', () => {
                this.saveData();
            });
            
            // Автосохранение каждые 30 секунд
            setInterval(() => {
                this.saveData();
            }, 30000);
        },

        // Установка горячих клавиш
        setupHotkeys() {
            document.addEventListener('keydown', (e) => {
                // Alt+N - Новое судно
                if (e.altKey && e.key === 'n') {
                    e.preventDefault();
                    this.addNewVessel();
                }
                
                // Alt+R - Обновить
                if (e.altKey && e.key === 'r') {
                    e.preventDefault();
                    this.refreshVesselList();
                }
                
                // Alt+M - Карта
                if (e.altKey && e.key === 'm') {
                    e.preventDefault();
                    this.switchTab('map');
                }
                
                // Escape - Закрыть модальное окно
                if (e.key === 'Escape') {
                    this.closeAllModals();
                }
            });
        },

        // Запуск автообновления
        startAutoUpdate() {
            // Обновление статистики каждые 5 секунд
            setInterval(() => {
                this.updateStatistics();
            }, 5000);
            
            // Обновление времени синхронизации
            setInterval(() => {
                this.updateSyncTime();
            }, 1000);
        }
<!-- ПРОДОЛЖЕНИЕ index.html - ЧАСТЬ 5 (строки 2401-3000) -->
<!-- ===== КЛАССЫ КОМПОНЕНТОВ ===== -->

        // Класс для управления автоподтверждением операций
        class AutoConfirmationManager {
            constructor() {
                this.enabled = localStorage.getItem('autoConfirmEnabled') === 'true';
                this.adminPassword = 'Admin@SSTO2025'; // В production должно быть в .env
                this.lastModified = localStorage.getItem('autoConfirmLastModified') || null;
                this.modifiedBy = localStorage.getItem('autoConfirmModifiedBy') || null;
                this.auditLog = JSON.parse(localStorage.getItem('autoConfirmAuditLog') || '[]');
            }

            toggleAutoConfirmation(password, reason, userId) {
                if (password !== this.adminPassword) {
                    throw new Error('Неверный пароль администратора');
                }

                this.enabled = !this.enabled;
                const timestamp = new Date().toISOString();
                
                // Сохранение настроек
                localStorage.setItem('autoConfirmEnabled', this.enabled.toString());
                localStorage.setItem('autoConfirmLastModified', timestamp);
                localStorage.setItem('autoConfirmModifiedBy', userId);

                // Запись в аудит
                const auditEntry = {
                    action: this.enabled ? 'ENABLED' : 'DISABLED',
                    timestamp: timestamp,
                    userId: userId,
                    reason: reason,
                    ip: '127.0.0.1' // В production получать реальный IP
                };

                this.auditLog.push(auditEntry);
                localStorage.setItem('autoConfirmAuditLog', JSON.stringify(this.auditLog));

                // Отправка уведомления
                this.sendNotification(auditEntry);

                return {
                    success: true,
                    enabled: this.enabled,
                    message: `Автоматическое подтверждение ${this.enabled ? 'включено' : 'отключено'}`
                };
            }

            processSignal(signal) {
                if (!this.enabled) {
                    return { processed: false, reason: 'Автоподтверждение отключено' };
                }

                // Поиск соответствующей заявки по номеру стойки
                const requests = JSON.parse(localStorage.getItem('testRequests') || '[]');
                const matchingRequest = requests.find(req => 
                    req.stationNumber === signal.stationNumber &&
                    req.status === 'pending' &&
                    this.isWithinTimeWindow(req.testDate, signal.receivedAt)
                );

                if (!matchingRequest) {
                    return { processed: false, reason: 'Соответствующая заявка не найдена' };
                }

                // Автоматическое подтверждение
                const confirmation = this.generateConfirmation(matchingRequest, signal);
                this.sendConfirmation(confirmation);

                // Обновление статусов
                matchingRequest.status = 'confirmed';
                matchingRequest.confirmedAt = new Date().toISOString();
                matchingRequest.confirmationId = confirmation.id;
                
                // Сохранение изменений
                const updatedRequests = requests.map(req => 
                    req.id === matchingRequest.id ? matchingRequest : req
                );
                localStorage.setItem('testRequests', JSON.stringify(updatedRequests));

                return {
                    processed: true,
                    confirmationId: confirmation.id,
                    requestId: matchingRequest.id
                };
            }

            isWithinTimeWindow(requestTime, signalTime, windowMinutes = 30) {
                const requestDate = new Date(requestTime);
                const signalDate = new Date(signalTime);
                const diffMinutes = Math.abs(requestDate - signalDate) / 60000;
                return diffMinutes <= windowMinutes;
            }

            generateConfirmation(request, signal) {
                return {
                    id: `CONF-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                    requestId: request.id,
                    stationNumber: request.stationNumber,
                    vesselName: request.vesselName,
                    mmsi: request.mmsi,
                    imo: request.imo,
                    shipOwner: request.shipOwner,
                    testDate: request.testDate,
                    signalReceivedAt: signal.receivedAt,
                    confirmedAt: new Date().toISOString(),
                    operator: 'AUTO',
                    status: 'SUCCESS'
                };
            }

            sendConfirmation(confirmation) {
                // В production отправка через EmailProcessor
                console.log('📧 Отправка подтверждения:', confirmation);
                
                // Сохранение в локальное хранилище
                const confirmations = JSON.parse(localStorage.getItem('confirmations') || '[]');
                confirmations.push(confirmation);
                localStorage.setItem('confirmations', JSON.stringify(confirmations));
            }

            sendNotification(auditEntry) {
                // В production отправка через WebSocket или email
                console.log('🔔 Уведомление об изменении настроек:', auditEntry);
            }

            getAuditLog(limit = 10) {
                return this.auditLog.slice(-limit);
            }
        }

        // Класс для обработки email сигналов
        class EmailProcessor {
            constructor() {
                this.emailQueue = JSON.parse(localStorage.getItem('emailQueue') || '[]');
                this.processedEmails = JSON.parse(localStorage.getItem('processedEmails') || '[]');
                this.emailPatterns = {
                    inmarsat: /INMARSAT.*SSAS.*ALERT/i,
                    iridium: /IRIDIUM.*EMERGENCY/i,
                    stationNumber: /Station\s*Number[:\s]*(\d{9})/i,
                    mmsi: /MMSI[:\s]*(\d{9})/i,
                    coordinates: /LAT[:\s]*([\d.-]+).*LON[:\s]*([\d.-]+)/i
                };
            }

            parseEmail(emailContent) {
                const parsed = {
                    type: null,
                    stationNumber: null,
                    mmsi: null,
                    coordinates: null,
                    timestamp: new Date().toISOString(),
                    rawContent: emailContent
                };

                // Определение типа системы
                if (this.emailPatterns.inmarsat.test(emailContent)) {
                    parsed.type = 'INMARSAT';
                } else if (this.emailPatterns.iridium.test(emailContent)) {
                    parsed.type = 'IRIDIUM';
                }

                // Извлечение номера стойки
                const stationMatch = emailContent.match(this.emailPatterns.stationNumber);
                if (stationMatch) {
                    parsed.stationNumber = stationMatch[1];
                }

                // Извлечение MMSI
                const mmsiMatch = emailContent.match(this.emailPatterns.mmsi);
                if (mmsiMatch) {
                    parsed.mmsi = mmsiMatch[1];
                }

                // Извлечение координат
                const coordsMatch = emailContent.match(this.emailPatterns.coordinates);
                if (coordsMatch) {
                    parsed.coordinates = {
                        lat: parseFloat(coordsMatch[1]),
                        lon: parseFloat(coordsMatch[2])
                    };
                }

                return parsed;
            }

            processEmailBatch(emails) {
                const results = [];
                
                for (const email of emails) {
                    // Проверка на дубликаты
                    if (this.processedEmails.includes(email.id)) {
                        results.push({
                            emailId: email.id,
                            status: 'DUPLICATE',
                            message: 'Email уже обработан'
                        });
                        continue;
                    }

                    // Парсинг email
                    const parsedData = this.parseEmail(email.content);
                    
                    // Валидация обязательных полей
                    if (!parsedData.stationNumber) {
                        results.push({
                            emailId: email.id,
                            status: 'ERROR',
                            message: 'Номер стойки не найден в email'
                        });
                        continue;
                    }

                    // Создание сигнала
                    const signal = this.createSignalFromEmail(parsedData, email);
                    
                    // Добавление в очередь обработки
                    this.emailQueue.push(signal);
                    this.processedEmails.push(email.id);
                    
                    results.push({
                        emailId: email.id,
                        status: 'SUCCESS',
                        signalId: signal.id,
                        stationNumber: signal.stationNumber
                    });
                }

                // Сохранение состояния
                localStorage.setItem('emailQueue', JSON.stringify(this.emailQueue));
                localStorage.setItem('processedEmails', JSON.stringify(this.processedEmails));

                return results;
            }

            createSignalFromEmail(parsedData, email) {
                return {
                    id: `SIG-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                    stationNumber: parsedData.stationNumber,
                    mmsi: parsedData.mmsi,
                    type: parsedData.type || 'UNKNOWN',
                    coordinates: parsedData.coordinates,
                    receivedAt: email.receivedAt || new Date().toISOString(),
                    emailId: email.id,
                    status: 'PENDING',
                    isTest: email.subject?.includes('TEST') || false
                };
            }

            getQueueStatus() {
                return {
                    queueLength: this.emailQueue.length,
                    processedCount: this.processedEmails.length,
                    lastProcessed: this.processedEmails[this.processedEmails.length - 1] || null
                };
            }

            clearProcessedEmails(olderThanDays = 30) {
                const cutoffDate = new Date();
                cutoffDate.setDate(cutoffDate.getDate() - olderThanDays);
                
                // В production фильтровать по дате
                // Для демо просто очищаем старые записи
                if (this.processedEmails.length > 1000) {
                    this.processedEmails = this.processedEmails.slice(-500);
                    localStorage.setItem('processedEmails', JSON.stringify(this.processedEmails));
                }
            }
        }

        // Класс для интеграции с API Поиск-Море
        class PoiskMoreIntegration {
            constructor() {
                this.apiUrl = 'https://api.poisk-more.ru/v1'; // Заглушка для демо
                this.apiKey = localStorage.getItem('poiskMoreApiKey') || 'demo-key';
                this.syncEnabled = localStorage.getItem('poiskMoreSyncEnabled') === 'true';
                this.lastSync = localStorage.getItem('poiskMoreLastSync') || null;
                this.syncLog = JSON.parse(localStorage.getItem('poiskMoreSyncLog') || '[]');
            }

            async sendToPoiskMore(signal) {
                if (!this.syncEnabled) {
                    return {
                        success: false,
                        message: 'Синхронизация с Поиск-Море отключена'
                    };
                }

                try {
                    // Подготовка данных для отправки
                    const payload = this.preparePayload(signal);
                    
                    // В production здесь будет реальный API запрос
                    // Для демо имитируем успешную отправку
                    const response = await this.simulateApiCall(payload);
                    
                    // Логирование синхронизации
                    this.logSync({
                        signalId: signal.id,
                        timestamp: new Date().toISOString(),
                        status: 'SUCCESS',
                        poiskMoreId: response.id
                    });

                    return {
                        success: true,
                        poiskMoreId: response.id,
                        message: 'Сигнал успешно передан в систему Поиск-Море'
                    };
                } catch (error) {
                    this.logSync({
                        signalId: signal.id,
                        timestamp: new Date().toISOString(),
                        status: 'ERROR',
                        error: error.message
                    });

                    return {
                        success: false,
                        message: `Ошибка при отправке: ${error.message}`
                    };
                }
            }

            preparePayload(signal) {
                return {
                    externalId: signal.id,
                    stationNumber: signal.stationNumber,
                    mmsi: signal.mmsi,
                    imo: signal.imo,
                    vesselName: signal.vesselName,
                    coordinates: signal.coordinates,
                    signalType: signal.isTest ? 'TEST' : 'ALERT',
                    receivedAt: signal.receivedAt,
                    metadata: {
                        source: 'SSTO_MODULE',
                        version: '1.0.0',
                        operator: signal.operator || 'AUTO'
                    }
                };
            }

            async simulateApiCall(payload) {
                // Имитация задержки сети
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Имитация ответа API
                return {
                    id: `PM-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                    status: 'RECEIVED',
                    receivedAt: new Date().toISOString(),
                    externalId: payload.externalId
                };
            }

            async syncBatch(signals) {
                const results = [];
                
                for (const signal of signals) {
                    const result = await this.sendToPoiskMore(signal);
                    results.push({
                        signalId: signal.id,
                        ...result
                    });
                    
                    // Задержка между запросами для избежания перегрузки
                    await new Promise(resolve => setTimeout(resolve, 100));
                }

                this.lastSync = new Date().toISOString();
                localStorage.setItem('poiskMoreLastSync', this.lastSync);

                return results;
            }

            logSync(entry) {
                this.syncLog.push(entry);
                
                // Ограничение размера лога
                if (this.syncLog.length > 1000) {
                    this.syncLog = this.syncLog.slice(-500);
                }
                
                localStorage.setItem('poiskMoreSyncLog', JSON.stringify(this.syncLog));
            }

            getSyncStatus() {
                const recentLogs = this.syncLog.slice(-10);
                const successCount = this.syncLog.filter(log => log.status === 'SUCCESS').length;
                const errorCount = this.syncLog.filter(log => log.status === 'ERROR').length;

                return {
                    enabled: this.syncEnabled,
                    lastSync: this.lastSync,
                    totalSynced: this.syncLog.length,
                    successCount: successCount,
                    errorCount: errorCount,
                    successRate: this.syncLog.length > 0 
                        ? ((successCount / this.syncLog.length) * 100).toFixed(2) + '%'
                        : '0%',
                    recentLogs: recentLogs
                };
            }

            toggleSync(enabled) {
                this.syncEnabled = enabled;
                localStorage.setItem('poiskMoreSyncEnabled', enabled.toString());
                
                return {
                    success: true,
                    enabled: this.syncEnabled,
                    message: `Синхронизация ${this.syncEnabled ? 'включена' : 'отключена'}`
                };
            }
        }

        // Класс для управления базой данных судов
        class VesselDB {
            constructor() {
                this.vessels = JSON.parse(localStorage.getItem('vessels') || '[]');
                this.initDefaultVessels();
            }

            initDefaultVessels() {
                if (this.vessels.length === 0) {
                    this.vessels = [
                        {
                            id: 'V001',
                            name: 'АКАДЕМИК ЛОМОНОСОВ',
                            mmsi: '273456789',
                            imo: '9876543',
                            callSign: 'UBXR',
                            flag: 'RU',
                            type: 'Research Vessel',
                            stationNumbers: ['427309676', '427309677'],
                            owner: 'Российская Академия Наук',
                            operator: 'РАН Флот',
                            email: 'fleet@ras.ru',
                            satcomType: 'INMARSAT',
                            lastTest: '2025-01-15T10:00:00Z',
                            nextTest: '2025-02-15T10:00:00Z',
                            status: 'ACTIVE'
                        },
                        {
                            id: 'V002',
                            name: 'КАПИТАН ВОРОНИН',
                            mmsi: '273456790',
                            imo: '9876544',
                            callSign: 'UBXS',
                            flag: 'RU',
                            type: 'Cargo',
                            stationNumbers: ['427309678'],
                            owner: 'Северное Морское Пароходство',
                            operator: 'СМП',
                            email: 'dispatch@smp.ru',
                            satcomType: 'IRIDIUM',
                            lastTest: '2025-01-20T14:00:00Z',
                            nextTest: '2025-02-20T14:00:00Z',
                            status: 'ACTIVE'
                        },
                        {
                            id: 'V003',
                            name: 'ВИКТОР ЧЕРНОМЫРДИН',
                            mmsi: '273456791',
                            imo: '9876545',
                            callSign: 'UBXT',
                            flag: 'RU',
                            type: 'Icebreaker',
                            stationNumbers: ['427309679', '427309680'],
                            owner: 'Росатомфлот',
                            operator: 'Атомфлот',
                            email: 'operations@rosatomflot.ru',
                            satcomType: 'INMARSAT',
                            lastTest: '2025-01-10T08:00:00Z',
                            nextTest: '2025-02-10T08:00:00Z',
                            status: 'ACTIVE'
                        }
                    ];
                    this.save();
                }
            }

            save() {
                localStorage.setItem('vessels', JSON.stringify(this.vessels));
            }

            addVessel(vessel) {
                // Валидация обязательных полей
                if (!vessel.mmsi || !vessel.name || !vessel.stationNumbers) {
                    throw new Error('Отсутствуют обязательные поля: MMSI, название или номера стоек');
                }

                // Проверка уникальности MMSI
                if (this.vessels.find(v => v.mmsi === vessel.mmsi)) {
                    throw new Error(`Судно с MMSI ${vessel.mmsi} уже существует`);
                }

                // Проверка уникальности номеров стоек
                const allStationNumbers = this.vessels.flatMap(v => v.stationNumbers || []);
                const duplicateStations = vessel.stationNumbers.filter(sn => 
                    allStationNumbers.includes(sn)
                );
                if (duplicateStations.length > 0) {
                    throw new Error(`Номера стоек уже используются: ${duplicateStations.join(', ')}`);
                }

                vessel.id = `V${Date.now()}`;
                vessel.createdAt = new Date().toISOString();
                vessel.status = vessel.status || 'ACTIVE';
                
                this.vessels.push(vessel);
                this.save();
                
                return vessel;
            }

            updateVessel(id, updates) {
                const index = this.vessels.findIndex(v => v.id === id);
                if (index === -1) {
                    throw new Error(`Судно с ID ${id} не найдено`);
                }

                // Проверка уникальности при изменении MMSI
                if (updates.mmsi && updates.mmsi !== this.vessels[index].mmsi) {
                    if (this.vessels.find(v => v.mmsi === updates.mmsi && v.id !== id)) {
                        throw new Error(`MMSI ${updates.mmsi} уже используется другим судном`);
                    }
                }

                this.vessels[index] = {
                    ...this.vessels[index],
                    ...updates,
                    updatedAt: new Date().toISOString()
                };
                
                this.save();
                return this.vessels[index];
            }

            deleteVessel(id) {
                const index = this.vessels.findIndex(v => v.id === id);
                if (index === -1) {
                    throw new Error(`Судно с ID ${id} не найдено`);
                }

                const deleted = this.vessels.splice(index, 1)[0];
                this.save();
                return deleted;
            }

            findByMMSI(mmsi) {
                return this.vessels.find(v => v.mmsi === mmsi);
            }

            findByStationNumber(stationNumber) {
                return this.vessels.find(v => 
                    v.stationNumbers && v.stationNumbers.includes(stationNumber)
                );
            }

            searchVessels(query) {
                const searchTerm = query.toLowerCase();
                return this.vessels.filter(v => 
                    v.name.toLowerCase().includes(searchTerm) ||
                    v.mmsi.includes(searchTerm) ||
                    v.imo?.includes(searchTerm) ||
                    v.callSign?.toLowerCase().includes(searchTerm) ||
                    (v.stationNumbers && v.stationNumbers.some(sn => sn.includes(searchTerm)))
                );
            }

            getActiveVessels() {
                return this.vessels.filter(v => v.status === 'ACTIVE');
            }

            getVesselsByOwner(owner) {
                return this.vessels.filter(v => v.owner === owner);
            }

            getTestSchedule(days = 30) {
                const futureDate = new Date();
                futureDate.setDate(futureDate.getDate() + days);
                
                return this.vessels
                    .filter(v => v.nextTest && new Date(v.nextTest) <= futureDate)
                    .sort((a, b) => new Date(a.nextTest) - new Date(b.nextTest))
                    .map(v => ({
                        vesselId: v.id,
                        vesselName: v.name,
                        mmsi: v.mmsi,
                        nextTest: v.nextTest,
                        satcomType: v.satcomType,
                        stationNumbers: v.stationNumbers
                    }));
            }

            updateTestDate(vesselId, testDate) {
                const vessel = this.vessels.find(v => v.id === vesselId);
                if (!vessel) {
                    throw new Error(`Судно с ID ${vesselId} не найдено`);
                }

                vessel.lastTest = testDate;
                
                // Автоматический расчет следующего теста (через 30 дней)
                const nextTest = new Date(testDate);
                nextTest.setDate(nextTest.getDate() + 30);
                vessel.nextTest = nextTest.toISOString();
                
                this.save();
                return vessel;
            }

            exportToCSV() {
                const headers = ['ID', 'Название', 'MMSI', 'IMO', 'Позывной', 'Флаг', 'Тип', 
                               'Номера стоек', 'Владелец', 'Оператор', 'Email', 'Тип связи', 
                               'Последний тест', 'Следующий тест', 'Статус'];
                
                const rows = this.vessels.map(v => [
                    v.id,
                    v.name,
                    v.mmsi,
                    v.imo || '',
                    v.callSign || '',
                    v.flag || '',
                    v.type || '',
                    (v.stationNumbers || []).join(';'),
                    v.owner || '',
                    v.operator || '',
                    v.email || '',
                    v.satcomType || '',
                    v.lastTest || '',
                    v.nextTest || '',
                    v.status
                ]);

                const csvContent = [
                    headers.join(','),
                    ...rows.map(row => row.map(cell => `"${cell}"`).join(','))
                ].join('\n');

                return csvContent;
            }

            importFromCSV(csvContent) {
                const lines = csvContent.split('\n');
                const headers = lines[0].split(',').map(h => h.replace(/"/g, '').trim());
                
                const imported = [];
                const errors = [];

                for (let i = 1; i < lines.length; i++) {
                    if (!lines[i].trim()) continue;
                    
                    try {
                        const values = lines[i].match(/(".*?"|[^,]+)/g)
                            .map(v => v.replace(/"/g, '').trim());
                        
                        const vessel = {
                            name: values[1],
                            mmsi: values[2],
                            imo: values[3] || undefined,
                            callSign: values[4] || undefined,
                            flag: values[5] || undefined,
                            type: values[6] || undefined,
                            stationNumbers: values[7] ? values[7].split(';') : [],
                            owner: values[8] || undefined,
                            operator: values[9] || undefined,
                            email: values[10] || undefined,
                            satcomType: values[11] || undefined,
                            lastTest: values[12] || undefined,
                            nextTest: values[13] || undefined,
                            status: values[14] || 'ACTIVE'
                        };

                        this.addVessel(vessel);
                        imported.push(vessel);
                    } catch (error) {
                        errors.push({
                            line: i + 1,
                            error: error.message
                        });
                    }
                }

                return {
                    imported: imported.length,
                    errors: errors
                };
            }

            getStatistics() {
                const total = this.vessels.length;
                const active = this.vessels.filter(v => v.status === 'ACTIVE').length;
                const byType = {};
                const bySatcom = {};
                
                this.vessels.forEach(v => {
                    byType[v.type || 'Unknown'] = (byType[v.type || 'Unknown'] || 0) + 1;
                    bySatcom[v.satcomType || 'Unknown'] = (bySatcom[v.satcomType || 'Unknown'] || 0) + 1;
                });

                const testsThisMonth = this.vessels.filter(v => {
                    if (!v.lastTest) return false;
                    const testDate = new Date(v.lastTest);
                    const now = new Date();
                    return testDate.getMonth() === now.getMonth() && 
                           testDate.getFullYear() === now.getFullYear();
                }).length;

                const upcomingTests = this.vessels.filter(v => {
                    if (!v.nextTest) return false;
                    const nextTest = new Date(v.nextTest);
                    const weekFromNow = new Date();
                    weekFromNow.setDate(weekFromNow.getDate() + 7);
                    return nextTest <= weekFromNow;
                }).length;

                return {
                    total,
                    active,
                    inactive: total - active,
                    byType,
                    bySatcom,
                    testsThisMonth,
                    upcomingTests
                };
            }
        }

<!-- КОНЕЦ ЧАСТИ 5 -->
<!-- Для продолжения в ЧАСТИ 6 будут добавлены функции приложения и вспомогательные функции -->
<!-- ПРОДОЛЖЕНИЕ index.html - ЧАСТЬ 6 (строки 3001-3600) -->
<!-- ===== ФУНКЦИИ ПРИЛОЖЕНИЯ ===== -->

        // ===== ИНИЦИАЛИЗАЦИЯ ПРИЛОЖЕНИЯ =====
        const app = {
            autoConfirmManager: null,
            emailProcessor: null,
            poiskMoreIntegration: null,
            vesselDB: null,
            map: null,
            markers: [],
            currentTab: 'dashboard',
            filters: {
                dateFrom: null,
                dateTo: null,
                status: 'all',
                vesselMMSI: null,
                signalType: 'all'
            }
        };

        // Функция инициализации при загрузке страницы
        function initializeApp() {
            console.log('🚀 Инициализация модуля ТЕСТ ССТО...');
            
            // Инициализация классов
            app.autoConfirmManager = new AutoConfirmationManager();
            app.emailProcessor = new EmailProcessor();
            app.poiskMoreIntegration = new PoiskMoreIntegration();
            app.vesselDB = new VesselDB();
            
            // Загрузка начальных данных
            loadDashboardData();
            loadRequests();
            loadSignals();
            loadTerminals();
            initializeMap();
            
            // Установка обработчиков событий
            setupEventHandlers();
            
            // Обновление статуса автоподтверждения
            updateAutoConfirmStatus();
            
            // Запуск периодического обновления
            startPeriodicUpdate();
            
            console.log('✅ Модуль успешно инициализирован');
        }

        // Функция переключения вкладок
        function switchTab(tabName) {
            // Скрытие всех вкладок
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.style.display = 'none';
            });
            
            // Удаление активного класса у всех кнопок
            document.querySelectorAll('.tab').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Показ выбранной вкладки
            const selectedTab = document.getElementById(tabName);
            if (selectedTab) {
                selectedTab.style.display = 'block';
            }
            
            // Добавление активного класса к кнопке
            const tabButton = document.querySelector(`.tab[onclick*="${tabName}"]`);
            if (tabButton) {
                tabButton.classList.add('active');
            }
            
            app.currentTab = tabName;
            
            // Специальная обработка для карты
            if (tabName === 'map-container' && app.map) {
                setTimeout(() => {
                    app.map.updateSize();
                }, 100);
            }
        }

        // Функция загрузки данных дашборда
        function loadDashboardData() {
            const stats = app.vesselDB.getStatistics();
            const requests = JSON.parse(localStorage.getItem('testRequests') || '[]');
            const signals = JSON.parse(localStorage.getItem('signals') || '[]');
            
            // Обновление статистики
            document.getElementById('total-requests').textContent = requests.length;
            document.getElementById('pending-requests').textContent = 
                requests.filter(r => r.status === 'pending').length;
            document.getElementById('confirmed-requests').textContent = 
                requests.filter(r => r.status === 'confirmed').length;
            document.getElementById('total-signals').textContent = signals.length;
            
            // Обновление графиков (если есть)
            updateCharts();
        }

        // Функция загрузки заявок
        function loadRequests() {
            const requests = JSON.parse(localStorage.getItem('testRequests') || '[]');
            const tbody = document.getElementById('requests-tbody');
            
            if (!tbody) return;
            
            tbody.innerHTML = '';
            
            requests.forEach(request => {
                const vessel = app.vesselDB.findByMMSI(request.mmsi);
                const row = document.createElement('tr');
                
                row.innerHTML = `
                    <td>${request.id}</td>
                    <td><strong>${request.stationNumber}</strong></td>
                    <td>${vessel ? vessel.name : request.vesselName}</td>
                    <td>${request.mmsi}</td>
                    <td>${formatDate(request.testDate)}</td>
                    <td><span class="status-badge status-${request.status}">${
                        getStatusText(request.status)
                    }</span></td>
                    <td>
                        <button onclick="viewRequest('${request.id}')" class="btn-small">
                            👁️ Просмотр
                        </button>
                        ${request.status === 'pending' ? `
                            <button onclick="confirmRequest('${request.id}')" class="btn-small btn-success">
                                ✅ Подтвердить
                            </button>
                        ` : ''}
                    </td>
                `;
                
                tbody.appendChild(row);
            });
        }

        // Функция загрузки сигналов
        function loadSignals() {
            const signals = JSON.parse(localStorage.getItem('signals') || '[]');
            const tbody = document.getElementById('signals-tbody');
            
            if (!tbody) return;
            
            tbody.innerHTML = '';
            
            signals.forEach(signal => {
                const vessel = app.vesselDB.findByStationNumber(signal.stationNumber);
                const row = document.createElement('tr');
                
                row.innerHTML = `
                    <td>${signal.id}</td>
                    <td><strong>${signal.stationNumber}</strong></td>
                    <td>${vessel ? vessel.name : 'Неизвестно'}</td>
                    <td>${signal.mmsi || '-'}</td>
                    <td>${signal.type}</td>
                    <td>${formatDate(signal.receivedAt)}</td>
                    <td>${signal.isTest ? '✅ Тест' : '🚨 Тревога'}</td>
                    <td>
                        <button onclick="viewSignal('${signal.id}')" class="btn-small">
                            👁️ Детали
                        </button>
                        ${!signal.isTest ? `
                            <button onclick="sendToPoiskMore('${signal.id}')" class="btn-small btn-danger">
                                📡 В Поиск-Море
                            </button>
                        ` : ''}
                    </td>
                `;
                
                tbody.appendChild(row);
            });
        }

        // Функция загрузки терминалов
        function loadTerminals() {
            const vessels = app.vesselDB.getActiveVessels();
            const tbody = document.getElementById('terminals-tbody');
            
            if (!tbody) return;
            
            tbody.innerHTML = '';
            
            vessels.forEach(vessel => {
                vessel.stationNumbers.forEach(stationNumber => {
                    const row = document.createElement('tr');
                    
                    row.innerHTML = `
                        <td><strong>${stationNumber}</strong></td>
                        <td>${vessel.name}</td>
                        <td>${vessel.mmsi}</td>
                        <td>${vessel.satcomType}</td>
                        <td>${vessel.owner}</td>
                        <td>${formatDate(vessel.lastTest)}</td>
                        <td>${formatDate(vessel.nextTest)}</td>
                        <td><span class="status-badge status-active">Активен</span></td>
                        <td>
                            <button onclick="editTerminal('${stationNumber}')" class="btn-small">
                                ✏️ Изменить
                            </button>
                            <button onclick="testTerminal('${stationNumber}')" class="btn-small btn-primary">
                                🔧 Тест
                            </button>
                        </td>
                    `;
                    
                    tbody.appendChild(row);
                });
            });
        }

        // Функция отправки новой заявки
        function submitRequest() {
            const stationNumber = document.getElementById('station-number').value;
            const vesselName = document.getElementById('vessel-name').value;
            const mmsi = document.getElementById('mmsi').value;
            const imo = document.getElementById('imo').value;
            const shipOwner = document.getElementById('ship-owner').value;
            const email = document.getElementById('email').value;
            const testDate = document.getElementById('test-date').value;
            const testTime = document.getElementById('test-time').value;
            const satcomType = document.querySelector('input[name="satcom-type"]:checked')?.value;
            
            // Валидация
            if (!stationNumber || !vesselName || !mmsi || !testDate || !testTime || !satcomType) {
                showNotification('Заполните все обязательные поля', 'error');
                return;
            }
            
            if (!validateMMSI(mmsi)) {
                showNotification('Неверный формат MMSI (должен быть 9 цифр)', 'error');
                return;
            }
            
            if (imo && !validateIMO(imo)) {
                showNotification('Неверный формат IMO', 'error');
                return;
            }
            
            // Создание заявки
            const request = {
                id: `REQ-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                stationNumber: stationNumber,
                vesselName: vesselName,
                mmsi: mmsi,
                imo: imo,
                shipOwner: shipOwner,
                email: email,
                testDate: `${testDate}T${testTime}:00`,
                satcomType: satcomType,
                status: 'pending',
                createdAt: new Date().toISOString(),
                operator: 'USER'
            };
            
            // Сохранение заявки
            const requests = JSON.parse(localStorage.getItem('testRequests') || '[]');
            requests.push(request);
            localStorage.setItem('testRequests', JSON.stringify(requests));
            
            // Обновление судна в базе
            let vessel = app.vesselDB.findByMMSI(mmsi);
            if (!vessel) {
                vessel = app.vesselDB.addVessel({
                    name: vesselName,
                    mmsi: mmsi,
                    imo: imo,
                    stationNumbers: [stationNumber],
                    owner: shipOwner,
                    email: email,
                    satcomType: satcomType
                });
            }
            
            // Очистка формы
            document.getElementById('request-form').reset();
            
            // Уведомление
            showNotification(`Заявка ${request.id} успешно создана`, 'success');
            
            // Обновление интерфейса
            loadRequests();
            loadDashboardData();
            
            // Переход на вкладку заявок
            switchTab('requests');
        }

        // Функция подтверждения заявки
        function confirmRequest(requestId) {
            const requests = JSON.parse(localStorage.getItem('testRequests') || '[]');
            const request = requests.find(r => r.id === requestId);
            
            if (!request) {
                showNotification('Заявка не найдена', 'error');
                return;
            }
            
            // Генерация подтверждения
            const confirmation = {
                id: `CONF-${Date.now()}`,
                requestId: requestId,
                stationNumber: request.stationNumber,
                vesselName: request.vesselName,
                mmsi: request.mmsi,
                confirmedAt: new Date().toISOString(),
                operator: 'USER'
            };
            
            // Обновление статуса заявки
            request.status = 'confirmed';
            request.confirmedAt = confirmation.confirmedAt;
            request.confirmationId = confirmation.id;
            
            // Сохранение изменений
            localStorage.setItem('testRequests', JSON.stringify(requests));
            
            const confirmations = JSON.parse(localStorage.getItem('confirmations') || '[]');
            confirmations.push(confirmation);
            localStorage.setItem('confirmations', JSON.stringify(confirmations));
            
            // Уведомление
            showNotification(`Заявка ${requestId} подтверждена`, 'success');
            
            // Обновление интерфейса
            loadRequests();
            loadDashboardData();
        }

        // Функция отправки в Поиск-Море
        async function sendToPoiskMore(signalId) {
            const signals = JSON.parse(localStorage.getItem('signals') || '[]');
            const signal = signals.find(s => s.id === signalId);
            
            if (!signal) {
                showNotification('Сигнал не найден', 'error');
                return;
            }
            
            // Показ индикатора загрузки
            showNotification('Отправка в Поиск-Море...', 'info');
            
            // Отправка через интеграцию
            const result = await app.poiskMoreIntegration.sendToPoiskMore(signal);
            
            if (result.success) {
                // Обновление сигнала
                signal.poiskMoreId = result.poiskMoreId;
                signal.sentToPoiskMore = true;
                signal.sentAt = new Date().toISOString();
                
                localStorage.setItem('signals', JSON.stringify(signals));
                
                showNotification(result.message, 'success');
                loadSignals();
            } else {
                showNotification(result.message, 'error');
            }
        }

        // ===== ФУНКЦИИ ВАЛИДАЦИИ =====
        
        function validateMMSI(mmsi) {
            return /^\d{9}$/.test(mmsi);
        }

        function validateIMO(imo) {
            if (!/^\d{7}$/.test(imo)) return false;
            
            // Алгоритм проверки контрольной цифры IMO
            let sum = 0;
            for (let i = 0; i < 6; i++) {
                sum += parseInt(imo[i]) * (7 - i);
            }
            return (sum % 10) === parseInt(imo[6]);
        }

        function validateStationNumber(stationNumber) {
            return /^\d{9}$/.test(stationNumber);
        }

        function validateEmail(email) {
            return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
        }

        // ===== ФУНКЦИИ ГЕНЕРАЦИИ ОТЧЕТОВ =====
        
        function generateDailyReport() {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            const requests = JSON.parse(localStorage.getItem('testRequests') || '[]');
            const signals = JSON.parse(localStorage.getItem('signals') || '[]');
            
            const todayRequests = requests.filter(r => {
                const date = new Date(r.createdAt);
                date.setHours(0, 0, 0, 0);
                return date.getTime() === today.getTime();
            });
            
            const todaySignals = signals.filter(s => {
                const date = new Date(s.receivedAt);
                date.setHours(0, 0, 0, 0);
                return date.getTime() === today.getTime();
            });
            
            const report = {
                date: today.toISOString().split('T')[0],
                type: 'daily',
                statistics: {
                    totalRequests: todayRequests.length,
                    confirmedRequests: todayRequests.filter(r => r.status === 'confirmed').length,
                    pendingRequests: todayRequests.filter(r => r.status === 'pending').length,
                    totalSignals: todaySignals.length,
                    testSignals: todaySignals.filter(s => s.isTest).length,
                    alertSignals: todaySignals.filter(s => !s.isTest).length
                },
                details: {
                    requests: todayRequests,
                    signals: todaySignals
                }
            };
            
            return report;
        }

        function generateWeeklyReport() {
            const endDate = new Date();
            const startDate = new Date();
            startDate.setDate(startDate.getDate() - 7);
            
            return generatePeriodReport(startDate, endDate, 'weekly');
        }

        function generateMonthlyReport() {
            const endDate = new Date();
            const startDate = new Date();
            startDate.setMonth(startDate.getMonth() - 1);
            
            return generatePeriodReport(startDate, endDate, 'monthly');
        }

        function generatePeriodReport(startDate, endDate, type) {
            const requests = JSON.parse(localStorage.getItem('testRequests') || '[]');
            const signals = JSON.parse(localStorage.getItem('signals') || '[]');
            
            const periodRequests = requests.filter(r => {
                const date = new Date(r.createdAt);
                return date >= startDate && date <= endDate;
            });
            
            const periodSignals = signals.filter(s => {
                const date = new Date(s.receivedAt);
                return date >= startDate && date <= endDate;
            });
            
            // Группировка по судам
            const vesselStats = {};
            periodRequests.forEach(r => {
                if (!vesselStats[r.mmsi]) {
                    vesselStats[r.mmsi] = {
                        vesselName: r.vesselName,
                        requests: 0,
                        confirmed: 0,
                        signals: 0
                    };
                }
                vesselStats[r.mmsi].requests++;
                if (r.status === 'confirmed') {
                    vesselStats[r.mmsi].confirmed++;
                }
            });
            
            periodSignals.forEach(s => {
                if (s.mmsi && vesselStats[s.mmsi]) {
                    vesselStats[s.mmsi].signals++;
                }
            });
            
            return {
                startDate: startDate.toISOString(),
                endDate: endDate.toISOString(),
                type: type,
                statistics: {
                    totalRequests: periodRequests.length,
                    confirmedRequests: periodRequests.filter(r => r.status === 'confirmed').length,
                    pendingRequests: periodRequests.filter(r => r.status === 'pending').length,
                    totalSignals: periodSignals.length,
                    testSignals: periodSignals.filter(s => s.isTest).length,
                    alertSignals: periodSignals.filter(s => !s.isTest).length,
                    uniqueVessels: Object.keys(vesselStats).length
                },
                vesselStatistics: vesselStats,
                details: {
                    requests: periodRequests,
                    signals: periodSignals
                }
            };
        }

        // ===== ФУНКЦИИ ЭКСПОРТА =====
        
        function exportToJSON(data, filename) {
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            downloadFile(blob, filename || 'export.json');
        }

        function exportToCSV(data, filename) {
            let csv = '';
            
            if (Array.isArray(data) && data.length > 0) {
                // Заголовки
                const headers = Object.keys(data[0]);
                csv = headers.join(',') + '\n';
                
                // Данные
                data.forEach(row => {
                    const values = headers.map(header => {
                        const value = row[header];
                        return typeof value === 'string' ? `"${value}"` : value;
                    });
                    csv += values.join(',') + '\n';
                });
            }
            
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            downloadFile(blob, filename || 'export.csv');
        }

        function exportToPDF(content, filename) {
            // Простая HTML-версия для печати
            const printWindow = window.open('', '_blank');
            printWindow.document.write(`
                <!DOCTYPE html>
                <html>
                <head>
                    <title>${filename || 'Отчет'}</title>
                    <style>
                        body { font-family: Arial, sans-serif; }
                        h1 { color: #333; }
                        table { width: 100%; border-collapse: collapse; }
                        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
                        th { background-color: #f2f2f2; }
                        @media print {
                            .no-print { display: none; }
                        }
                    </style>
                </head>
                <body>
                    ${content}
                    <button class="no-print" onclick="window.print()">Печать / Сохранить как PDF</button>
                </body>
                </html>
            `);
            printWindow.document.close();
        }

        function downloadFile(blob, filename) {
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        // ===== ФУНКЦИИ РАБОТЫ С КАРТОЙ =====
        
        function initializeMap() {
            if (!document.getElementById('map')) return;
            
            // Инициализация карты OpenLayers
            app.map = new ol.Map({
                target: 'map',
                layers: [
                    new ol.layer.Tile({
                        source: new ol.source.OSM()
                    })
                ],
                view: new ol.View({
                    center: ol.proj.fromLonLat([37.6173, 55.7558]), // Москва
                    zoom: 5
                })
            });
            
            // Добавление слоя OpenSeaMap
            const openSeaMapLayer = new ol.layer.Tile({
                source: new ol.source.XYZ({
                    url: 'https://tiles.openseamap.org/seamark/{z}/{x}/{y}.png',
                    attributions: 'Map data: © OpenSeaMap contributors'
                })
            });
            app.map.addLayer(openSeaMapLayer);
            
            // Загрузка маркеров
            loadMapMarkers();
        }

        function loadMapMarkers() {
            if (!app.map) return;
            
            // Очистка старых маркеров
            app.markers.forEach(marker => {
                app.map.removeLayer(marker);
            });
            app.markers = [];
            
            // Загрузка сигналов
            const signals = JSON.parse(localStorage.getItem('signals') || '[]');
            
            signals.forEach(signal => {
                if (signal.coordinates) {
                    addMarkerToMap(signal);
                }
            });
        }

        function addMarkerToMap(signal) {
            const iconFeature = new ol.Feature({
                geometry: new ol.geom.Point(
                    ol.proj.fromLonLat([signal.coordinates.lon, signal.coordinates.lat])
                ),
                signal: signal
            });
            
            const iconStyle = new ol.style.Style({
                image: new ol.style.Circle({
                    radius: 8,
                    fill: new ol.style.Fill({
                        color: signal.isTest ? 'rgba(0, 255, 0, 0.6)' : 'rgba(255, 0, 0, 0.6)'
                    }),
                    stroke: new ol.style.Stroke({
                        color: signal.isTest ? 'green' : 'red',
                        width: 2
                    })
                })
            });
            
            iconFeature.setStyle(iconStyle);
            
            const vectorSource = new ol.source.Vector({
                features: [iconFeature]
            });
            
            const vectorLayer = new ol.layer.Vector({
                source: vectorSource
            });
            
            app.map.addLayer(vectorLayer);
            app.markers.push(vectorLayer);
        }

        // ===== ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ =====
        
        function formatDate(dateString) {
            if (!dateString) return '-';
            const date = new Date(dateString);
            return date.toLocaleString('ru-RU', {
                day: '2-digit',
                month: '2-digit',
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        function getStatusText(status) {
            const statusMap = {
                'pending': 'Ожидает',
                'confirmed': 'Подтверждено',
                'cancelled': 'Отменено',
                'expired': 'Истекло'
            };
            return statusMap[status] || status;
        }

        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.classList.add('show');
            }, 10);
            
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 3000);
        }

        function updateAutoConfirmStatus() {
            const statusElement = document.getElementById('auto-confirm-status');
            if (statusElement) {
                statusElement.textContent = app.autoConfirmManager.enabled ? 'ВКЛЮЧЕН' : 'ОТКЛЮЧЕН';
                statusElement.className = app.autoConfirmManager.enabled ? 'status-active' : 'status-inactive';
            }
        }

        function toggleAutoConfirm() {
            const password = prompt('Введите пароль администратора:');
            if (!password) return;
            
            const reason = prompt('Укажите причину изменения:');
            if (!reason) return;
            
            try {
                const result = app.autoConfirmManager.toggleAutoConfirmation(
                    password,
                    reason,
                    'ADMIN'
                );
                
                showNotification(result.message, 'success');
                updateAutoConfirmStatus();
            } catch (error) {
                showNotification(error.message, 'error');
            }
        }

        function setupEventHandlers() {
            // Обработчики для форм
            const requestForm = document.getElementById('request-form');
            if (requestForm) {
                requestForm.addEventListener('submit', (e) => {
                    e.preventDefault();
                    submitRequest();
                });
            }
            
            // Обработчик изменения типа спутниковой связи
            const satcomRadios = document.querySelectorAll('input[name="satcom-type"]');
            satcomRadios.forEach(radio => {
                radio.addEventListener('change', (e) => {
                    const stationLabel = document.querySelector('label[for="station-number"]');
                    if (stationLabel) {
                        stationLabel.textContent = e.target.value === 'INMARSAT' 
                            ? 'Номер стойки ИНМАРСАТ:' 
                            : 'Номер стойки ИРИДИУМ:';
                    }
                });
            });
            
            // Обработчики для фильтров
            const filterInputs = document.querySelectorAll('.filter-input');
            filterInputs.forEach(input => {
                input.addEventListener('change', applyFilters);
            });
        }

        function applyFilters() {
            // Применение фильтров к таблицам
            const dateFrom = document.getElementById('filter-date-from')?.value;
            const dateTo = document.getElementById('filter-date-to')?.value;
            const status = document.getElementById('filter-status')?.value;
            
            app.filters = {
                dateFrom: dateFrom ? new Date(dateFrom) : null,
                dateTo: dateTo ? new Date(dateTo) : null,
                status: status || 'all'
            };
            
            // Перезагрузка данных с учетом фильтров
            loadRequests();
            loadSignals();
        }

        function updateCharts() {
            // Заглушка для обновления графиков
            console.log('Обновление графиков...');
        }

        function startPeriodicUpdate() {
            // Обновление данных каждые 30 секунд
            setInterval(() => {
                if (app.currentTab === 'dashboard') {
                    loadDashboardData();
                } else if (app.currentTab === 'signals') {
                    loadSignals();
                } else if (app.currentTab === 'requests') {
                    loadRequests();
                }
            }, 30000);
        }

        // ===== ФУНКЦИИ МОДАЛЬНЫХ ОКОН =====
        
        function viewRequest(requestId) {
            const requests = JSON.parse(localStorage.getItem('testRequests') || '[]');
            const request = requests.find(r => r.id === requestId);
            
            if (!request) {
                showNotification('Заявка не найдена', 'error');
                return;
            }
            
            alert(`Заявка: ${request.id}\nСтойка: ${request.stationNumber}\nСудно: ${request.vesselName}\nММSI: ${request.mmsi}\nДата теста: ${formatDate(request.testDate)}\nСтатус: ${getStatusText(request.status)}`);
        }

        function viewSignal(signalId) {
            const signals = JSON.parse(localStorage.getItem('signals') || '[]');
            const signal = signals.find(s => s.id === signalId);
            
            if (!signal) {
                showNotification('Сигнал не найден', 'error');
                return;
            }
            
            alert(`Сигнал: ${signal.id}\nСтойка: ${signal.stationNumber}\nТип: ${signal.type}\nПолучен: ${formatDate(signal.receivedAt)}\nТест: ${signal.isTest ? 'Да' : 'Нет'}`);
        }

        function editTerminal(stationNumber) {
            const vessel = app.vesselDB.findByStationNumber(stationNumber);
            if (!vessel) {
                showNotification('Терминал не найден', 'error');
                return;
            }
            
            const newName = prompt('Название судна:', vessel.name);
            if (newName && newName !== vessel.name) {
                vessel.name = newName;
                app.vesselDB.updateVessel(vessel.id, { name: newName });
                loadTerminals();
                showNotification('Терминал обновлен', 'success');
            }
        }

        function testTerminal(stationNumber) {
            const vessel = app.vesselDB.findByStationNumber(stationNumber);
            if (!vessel) {
                showNotification('Терминал не найден', 'error');
                return;
            }
            
            // Создание тестового сигнала
            const testSignal = {
                id: `SIG-TEST-${Date.now()}`,
                stationNumber: stationNumber,
                mmsi: vessel.mmsi,
                type: vessel.satcomType,
                coordinates: {
                    lat: 55.7558 + (Math.random() - 0.5) * 10,
                    lon: 37.6173 + (Math.random() - 0.5) * 10
                },
                receivedAt: new Date().toISOString(),
                isTest: true,
                status: 'RECEIVED'
            };
            
            // Сохранение сигнала
            const signals = JSON.parse(localStorage.getItem('signals') || '[]');
            signals.push(testSignal);
            localStorage.setItem('signals', JSON.stringify(signals));
            
            // Обновление даты последнего теста
            app.vesselDB.updateTestDate(vessel.id, testSignal.receivedAt);
            
            showNotification(`Тестовый сигнал от ${stationNumber} создан`, 'success');
            loadSignals();
            loadTerminals();
        }

<!-- КОНЕЦ ЧАСТИ 6 - ПОЛНАЯ ВЕРСИЯ (3600 строк) -->
<!-- ПРОДОЛЖЕНИЕ index.html - ЧАСТЬ 7 ФИНАЛЬНАЯ (строки 3601+) -->
<!-- ===== ДОПОЛНИТЕЛЬНЫЕ ФУНКЦИИ ===== -->

        // Функция обработки email очереди
        function processEmailQueue() {
            const queue = app.emailProcessor.emailQueue;
            
            if (queue.length === 0) {
                console.log('📧 Очередь email пуста');
                return;
            }
            
            console.log(`📧 Обработка ${queue.length} email сообщений...`);
            
            queue.forEach(signal => {
                // Проверка автоподтверждения
                if (app.autoConfirmManager.enabled) {
                    const result = app.autoConfirmManager.processSignal(signal);
                    if (result.processed) {
                        console.log(`✅ Сигнал ${signal.id} автоматически подтвержден`);
                    }
                }
            });
            
            // Очистка обработанной очереди
            app.emailProcessor.emailQueue = [];
            localStorage.setItem('emailQueue', '[]');
        }

        // Функция синхронизации с Поиск-Море
        async function syncWithPoiskMore() {
            const signals = JSON.parse(localStorage.getItem('signals') || '[]');
            const unsynced = signals.filter(s => !s.sentToPoiskMore && !s.isTest);
            
            if (unsynced.length === 0) {
                showNotification('Нет сигналов для синхронизации', 'info');
                return;
            }
            
            showNotification(`Синхронизация ${unsynced.length} сигналов...`, 'info');
            
            const results = await app.poiskMoreIntegration.syncBatch(unsynced);
            
            const successCount = results.filter(r => r.success).length;
            showNotification(`Синхронизировано: ${successCount} из ${unsynced.length}`, 
                            successCount === unsynced.length ? 'success' : 'warning');
            
            // Обновление статусов
            results.forEach(result => {
                if (result.success) {
                    const signal = signals.find(s => s.id === result.signalId);
                    if (signal) {
                        signal.sentToPoiskMore = true;
                        signal.poiskMoreId = result.poiskMoreId;
                    }
                }
            });
            
            localStorage.setItem('signals', JSON.stringify(signals));
            loadSignals();
        }

        // Функция экспорта настроек
        function exportSettings() {
            const settings = {
                version: '1.0.0',
                exportDate: new Date().toISOString(),
                autoConfirmation: {
                    enabled: app.autoConfirmManager.enabled,
                    lastModified: app.autoConfirmManager.lastModified,
                    modifiedBy: app.autoConfirmManager.modifiedBy
                },
                poiskMoreIntegration: {
                    enabled: app.poiskMoreIntegration.syncEnabled,
                    lastSync: app.poiskMoreIntegration.lastSync
                },
                vessels: app.vesselDB.vessels,
                statistics: app.vesselDB.getStatistics()
            };
            
            exportToJSON(settings, `ssto-settings-${Date.now()}.json`);
            showNotification('Настройки экспортированы', 'success');
        }

        // Функция импорта настроек
        function importSettings() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const settings = JSON.parse(event.target.result);
                        
                        // Валидация версии
                        if (!settings.version || !settings.vessels) {
                            throw new Error('Неверный формат файла настроек');
                        }
                        
                        // Импорт судов
                        settings.vessels.forEach(vessel => {
                            try {
                                app.vesselDB.addVessel(vessel);
                            } catch (err) {
                                console.warn(`Пропуск судна ${vessel.mmsi}: ${err.message}`);
                            }
                        });
                        
                        // Обновление интерфейса
                        loadTerminals();
                        loadDashboardData();
                        
                        showNotification('Настройки успешно импортированы', 'success');
                    } catch (error) {
                        showNotification(`Ошибка импорта: ${error.message}`, 'error');
                    }
                };
                
                reader.readAsText(file);
            };
            
            input.click();
        }

        // Функция очистки старых данных
        function cleanupOldData(daysToKeep = 30) {
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - daysToKeep);
            
            // Очистка заявок
            let requests = JSON.parse(localStorage.getItem('testRequests') || '[]');
            const beforeCount = requests.length;
            requests = requests.filter(r => new Date(r.createdAt) > cutoffDate);
            localStorage.setItem('testRequests', JSON.stringify(requests));
            
            // Очистка сигналов
            let signals = JSON.parse(localStorage.getItem('signals') || '[]');
            signals = signals.filter(s => new Date(s.receivedAt) > cutoffDate);
            localStorage.setItem('signals', JSON.stringify(signals));
            
            // Очистка логов
            app.emailProcessor.clearProcessedEmails(daysToKeep);
            
            const removedCount = beforeCount - requests.length;
            showNotification(`Удалено ${removedCount} старых записей`, 'info');
        }

        // Функция генерации тестовых данных (для демонстрации)
        function generateTestData() {
            const testRequests = [];
            const testSignals = [];
            const vessels = app.vesselDB.getActiveVessels();
            
            // Генерация тестовых заявок
            for (let i = 0; i < 5; i++) {
                const vessel = vessels[i % vessels.length];
                const date = new Date();
                date.setDate(date.getDate() - Math.floor(Math.random() * 7));
                
                testRequests.push({
                    id: `TEST-REQ-${Date.now()}-${i}`,
                    stationNumber: vessel.stationNumbers[0],
                    vesselName: vessel.name,
                    mmsi: vessel.mmsi,
                    imo: vessel.imo,
                    shipOwner: vessel.owner,
                    email: vessel.email,
                    testDate: date.toISOString(),
                    satcomType: vessel.satcomType,
                    status: Math.random() > 0.5 ? 'confirmed' : 'pending',
                    createdAt: date.toISOString(),
                    operator: 'TEST'
                });
            }
            
            // Генерация тестовых сигналов
            for (let i = 0; i < 10; i++) {
                const vessel = vessels[i % vessels.length];
                const date = new Date();
                date.setHours(date.getHours() - Math.floor(Math.random() * 24));
                
                testSignals.push({
                    id: `TEST-SIG-${Date.now()}-${i}`,
                    stationNumber: vessel.stationNumbers[0],
                    mmsi: vessel.mmsi,
                    type: vessel.satcomType,
                    coordinates: {
                        lat: 55.7558 + (Math.random() - 0.5) * 20,
                        lon: 37.6173 + (Math.random() - 0.5) * 40
                    },
                    receivedAt: date.toISOString(),
                    isTest: Math.random() > 0.2,
                    status: 'RECEIVED'
                });
            }
            
            // Сохранение тестовых данных
            const existingRequests = JSON.parse(localStorage.getItem('testRequests') || '[]');
            const existingSignals = JSON.parse(localStorage.getItem('signals') || '[]');
            
            localStorage.setItem('testRequests', JSON.stringify([...existingRequests, ...testRequests]));
            localStorage.setItem('signals', JSON.stringify([...existingSignals, ...testSignals]));
            
            // Обновление интерфейса
            loadRequests();
            loadSignals();
            loadDashboardData();
            loadMapMarkers();
            
            showNotification('Тестовые данные сгенерированы', 'success');
        }

        // Функция проверки системы
        function systemHealthCheck() {
            const checks = {
                localStorage: false,
                vessels: false,
                autoConfirm: false,
                poiskMore: false,
                map: false
            };
            
            // Проверка localStorage
            try {
                localStorage.setItem('health_check', 'ok');
                localStorage.removeItem('health_check');
                checks.localStorage = true;
            } catch (e) {
                console.error('localStorage недоступен:', e);
            }
            
            // Проверка базы судов
            checks.vessels = app.vesselDB.vessels.length > 0;
            
            // Проверка автоподтверждения
            checks.autoConfirm = app.autoConfirmManager !== null;
            
            // Проверка интеграции Поиск-Море
            checks.poiskMore = app.poiskMoreIntegration !== null;
            
            // Проверка карты
            checks.map = app.map !== null;
            
            const allChecks = Object.values(checks).every(check => check === true);
            
            if (allChecks) {
                showNotification('✅ Система работает нормально', 'success');
            } else {
                const failed = Object.entries(checks)
                    .filter(([key, value]) => !value)
                    .map(([key]) => key);
                showNotification(`⚠️ Проблемы с: ${failed.join(', ')}`, 'warning');
            }
            
            return checks;
        }

        // Функция получения версии системы
        function getSystemVersion() {
            return {
                name: 'Модуль ТЕСТ ССТО',
                version: '1.0.0',
                build: '2025.01.09',
                author: 'ГАМЦ Росморречфлот',
                description: 'Система управления тестированием судовой системы тревожной охранной сигнализации'
            };
        }

        // Функция показа справки
        function showHelp() {
            const version = getSystemVersion();
            const helpText = `
${version.name} v${version.version}
=====================================

ОСНОВНЫЕ ФУНКЦИИ:
• Создание заявок на тестирование ССТО
• Прием и обработка тестовых сигналов
• Автоматическое подтверждение (при включении)
• Интеграция с системой Поиск-Море
• Генерация отчетов

ГОРЯЧИЕ КЛАВИШИ:
• Alt+N - Новая заявка
• Alt+R - Обновить данные
• Alt+H - Справка

ВАЖНО:
Номер стойки ССТО - ключевой идентификатор!

Поддержка: support@morflot.ru
            `;
            
            alert(helpText);
        }

        // Функция установки горячих клавиш
        function setupHotkeys() {
            document.addEventListener('keydown', (e) => {
                // Alt+N - новая заявка
                if (e.altKey && e.key === 'n') {
                    e.preventDefault();
                    switchTab('new-request');
                }
                
                // Alt+R - обновить
                if (e.altKey && e.key === 'r') {
                    e.preventDefault();
                    location.reload();
                }
                
                // Alt+H - справка
                if (e.altKey && e.key === 'h') {
                    e.preventDefault();
                    showHelp();
                }
                
                // Alt+E - экспорт
                if (e.altKey && e.key === 'e') {
                    e.preventDefault();
                    exportSettings();
                }
                
                // Alt+I - импорт
                if (e.altKey && e.key === 'i') {
                    e.preventDefault();
                    importSettings();
                }
            });
        }

        // Функция инициализации уведомлений
        function initNotifications() {
            // Запрос разрешения на показ уведомлений
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission();
            }
        }

        // Функция показа браузерного уведомления
        function showBrowserNotification(title, body, icon = '🚢') {
            if ('Notification' in window && Notification.permission === 'granted') {
                new Notification(title, {
                    body: body,
                    icon: icon,
                    badge: icon,
                    tag: 'ssto-notification',
                    requireInteraction: false
                });
            }
        }

        // Функция проверки новых сигналов
        function checkForNewSignals() {
            const signals = JSON.parse(localStorage.getItem('signals') || '[]');
            const lastCheck = localStorage.getItem('lastSignalCheck');
            const newSignals = signals.filter(s => {
                if (!lastCheck) return false;
                return new Date(s.receivedAt) > new Date(lastCheck);
            });
            
            if (newSignals.length > 0) {
                const alertSignals = newSignals.filter(s => !s.isTest);
                if (alertSignals.length > 0) {
                    showBrowserNotification(
                        '🚨 Новые сигналы тревоги!',
                        `Получено ${alertSignals.length} сигналов тревоги`
                    );
                }
            }
            
            localStorage.setItem('lastSignalCheck', new Date().toISOString());
        }

        // Функция логирования событий
        function logEvent(eventType, eventData) {
            const eventLog = JSON.parse(localStorage.getItem('eventLog') || '[]');
            
            const event = {
                id: `EVT-${Date.now()}`,
                type: eventType,
                data: eventData,
                timestamp: new Date().toISOString(),
                user: 'OPERATOR'
            };
            
            eventLog.push(event);
            
            // Ограничение размера лога
            if (eventLog.length > 5000) {
                eventLog.splice(0, eventLog.length - 2500);
            }
            
            localStorage.setItem('eventLog', JSON.stringify(eventLog));
            
            console.log(`📝 Event: ${eventType}`, eventData);
        }

        // Функция получения статистики использования
        function getUsageStatistics() {
            const eventLog = JSON.parse(localStorage.getItem('eventLog') || '[]');
            const requests = JSON.parse(localStorage.getItem('testRequests') || '[]');
            const signals = JSON.parse(localStorage.getItem('signals') || '[]');
            
            const stats = {
                totalEvents: eventLog.length,
                totalRequests: requests.length,
                totalSignals: signals.length,
                confirmedRequests: requests.filter(r => r.status === 'confirmed').length,
                testSignals: signals.filter(s => s.isTest).length,
                alertSignals: signals.filter(s => !s.isTest).length,
                activeVessels: app.vesselDB.getActiveVessels().length,
                lastActivity: eventLog.length > 0 ? eventLog[eventLog.length - 1].timestamp : null
            };
            
            return stats;
        }
<!-- ДОПОЛНИТЕЛЬНЫЕ ФУНКЦИИ для index.html -->
<!-- Вставить перед закрывающим тегом </script> -->

        // ===== РАСШИРЕННЫЕ ФУНКЦИИ КАРТЫ =====
        
        class AdvancedMapManager {
            constructor() {
                this.map = null;
                this.vectorSource = null;
                this.clusterSource = null;
                this.popup = null;
                this.drawInteraction = null;
                this.measureTooltip = null;
                this.routeLayer = null;
                this.heatmapLayer = null;
            }

            initAdvancedMap() {
                // Базовые слои карты
                const osm = new ol.layer.Tile({
                    source: new ol.source.OSM(),
                    visible: true,
                    name: 'OSM'
                });

                const satellite = new ol.layer.Tile({
                    source: new ol.source.XYZ({
                        url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
                        attributions: 'Tiles © Esri'
                    }),
                    visible: false,
                    name: 'Satellite'
                });

                const seaMap = new ol.layer.Tile({
                    source: new ol.source.XYZ({
                        url: 'https://tiles.openseamap.org/seamark/{z}/{x}/{y}.png',
                        attributions: '© OpenSeaMap contributors'
                    }),
                    visible: true,
                    opacity: 0.7,
                    name: 'SeaMarks'
                });

                // Векторный источник для маркеров
                this.vectorSource = new ol.source.Vector();

                // Кластеризация маркеров
                this.clusterSource = new ol.source.Cluster({
                    distance: 40,
                    source: this.vectorSource
                });

                const clusterLayer = new ol.layer.Vector({
                    source: this.clusterSource,
                    style: this.clusterStyle.bind(this),
                    name: 'Signals'
                });

                // Создание карты
                this.map = new ol.Map({
                    target: 'map',
                    layers: [osm, satellite, seaMap, clusterLayer],
                    view: new ol.View({
                        center: ol.proj.fromLonLat([37.6173, 55.7558]),
                        zoom: 5,
                        minZoom: 3,
                        maxZoom: 18
                    }),
                    controls: ol.control.defaults().extend([
                        new ol.control.FullScreen(),
                        new ol.control.ScaleLine({
                            units: 'nautical'
                        }),
                        new ol.control.MousePosition({
                            coordinateFormat: ol.coordinate.createStringXY(4),
                            projection: 'EPSG:4326'
                        })
                    ])
                });

                // Добавление popup
                this.addPopup();
                
                // Добавление контролов
                this.addMapControls();
                
                // Загрузка сигналов на карту
                this.loadSignalsToMap();
                
                // Обработчики событий
                this.setupMapEventHandlers();
            }

            clusterStyle(feature) {
                const size = feature.get('features').length;
                let style;

                if (size > 1) {
                    // Стиль для кластера
                    style = new ol.style.Style({
                        image: new ol.style.Circle({
                            radius: 10 + Math.min(size * 0.5, 20),
                            stroke: new ol.style.Stroke({
                                color: '#fff',
                                width: 2
                            }),
                            fill: new ol.style.Fill({
                                color: size > 10 ? '#ff0000' : size > 5 ? '#ff9900' : '#00cc00'
                            })
                        }),
                        text: new ol.style.Text({
                            text: size.toString(),
                            fill: new ol.style.Fill({
                                color: '#fff'
                            })
                        })
                    });
                } else {
                    // Стиль для одиночного маркера
                    const signal = feature.get('features')[0].get('signal');
                    const isTest = signal.isTest;
                    const isRecent = (new Date() - new Date(signal.receivedAt)) < 3600000; // менее часа

                    style = new ol.style.Style({
                        image: new ol.style.Icon({
                            src: `data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="30" height="40" viewBox="0 0 30 40">
                                <path d="M15,0 C6.7,0 0,6.7 0,15 C0,23.3 15,40 15,40 S30,23.3 30,15 C30,6.7 23.3,0 15,0 Z" 
                                      fill="${isTest ? '#00cc00' : '#ff0000'}" stroke="#fff" stroke-width="2"/>
                                <circle cx="15" cy="15" r="5" fill="#fff"/>
                                ${isRecent ? '<animate attributeName="opacity" values="1;0.3;1" dur="1.5s" repeatCount="indefinite"/>' : ''}
                            </svg>`,
                            scale: 1,
                            anchor: [0.5, 1]
                        })
                    });
                }

                return style;
            }

            addPopup() {
                const container = document.createElement('div');
                container.className = 'ol-popup';
                container.innerHTML = `
                    <a href="#" class="ol-popup-closer">×</a>
                    <div class="ol-popup-content"></div>
                `;
                document.getElementById('map').appendChild(container);

                const closer = container.querySelector('.ol-popup-closer');
                const content = container.querySelector('.ol-popup-content');

                this.popup = new ol.Overlay({
                    element: container,
                    autoPan: true,
                    autoPanAnimation: {
                        duration: 250
                    }
                });

                this.map.addOverlay(this.popup);

                closer.onclick = () => {
                    this.popup.setPosition(undefined);
                    closer.blur();
                    return false;
                };
            }

            addMapControls() {
                // Панель управления слоями
                const layerControl = document.createElement('div');
                layerControl.className = 'map-layer-control';
                layerControl.innerHTML = `
                    <h4>Слои карты</h4>
                    <label><input type="radio" name="base-layer" value="OSM" checked> OpenStreetMap</label>
                    <label><input type="radio" name="base-layer" value="Satellite"> Спутник</label>
                    <label><input type="checkbox" id="seamarksToggle" checked> Морские знаки</label>
                    <label><input type="checkbox" id="heatmapToggle"> Тепловая карта</label>
                    <label><input type="checkbox" id="routesToggle"> Маршруты</label>
                `;

                const mapContainer = document.getElementById('map-container');
                if (mapContainer) {
                    mapContainer.appendChild(layerControl);
                }

                // Обработчики переключения слоев
                layerControl.addEventListener('change', (e) => {
                    if (e.target.name === 'base-layer') {
                        this.map.getLayers().forEach(layer => {
                            if (layer.get('name') === 'OSM' || layer.get('name') === 'Satellite') {
                                layer.setVisible(layer.get('name') === e.target.value);
                            }
                        });
                    }
                    
                    if (e.target.id === 'seamarksToggle') {
                        const seaLayer = this.map.getLayers().getArray().find(l => l.get('name') === 'SeaMarks');
                        if (seaLayer) seaLayer.setVisible(e.target.checked);
                    }
                    
                    if (e.target.id === 'heatmapToggle') {
                        this.toggleHeatmap(e.target.checked);
                    }
                    
                    if (e.target.id === 'routesToggle') {
                        this.toggleRoutes(e.target.checked);
                    }
                });

                // Панель инструментов
                const toolbar = document.createElement('div');
                toolbar.className = 'map-toolbar';
                toolbar.innerHTML = `
                    <button onclick="mapManager.zoomToSignals()">🎯 Показать все</button>
                    <button onclick="mapManager.measureDistance()">📏 Измерить</button>
                    <button onclick="mapManager.drawArea()">✏️ Выделить зону</button>
                    <button onclick="mapManager.exportMapImage()">📷 Скриншот</button>
                    <button onclick="mapManager.clearMap()">🗑️ Очистить</button>
                `;
                
                if (mapContainer) {
                    mapContainer.appendChild(toolbar);
                }
            }

            loadSignalsToMap() {
                const signals = JSON.parse(localStorage.getItem('signals') || '[]');
                
                this.vectorSource.clear();
                
                signals.forEach(signal => {
                    if (signal.coordinates) {
                        const feature = new ol.Feature({
                            geometry: new ol.geom.Point(
                                ol.proj.fromLonLat([signal.coordinates.lon, signal.coordinates.lat])
                            ),
                            signal: signal
                        });
                        
                        this.vectorSource.addFeature(feature);
                    }
                });
            }

            setupMapEventHandlers() {
                // Клик по карте
                this.map.on('click', (evt) => {
                    const feature = this.map.forEachFeatureAtPixel(evt.pixel, (feature) => feature);
                    
                    if (feature) {
                        const features = feature.get('features');
                        if (features && features.length === 1) {
                            const signal = features[0].get('signal');
                            this.showSignalPopup(signal, evt.coordinate);
                        } else if (features && features.length > 1) {
                            this.showClusterPopup(features, evt.coordinate);
                        }
                    }
                });

                // Изменение курсора при наведении
                this.map.on('pointermove', (evt) => {
                    const pixel = this.map.getEventPixel(evt.originalEvent);
                    const hit = this.map.hasFeatureAtPixel(pixel);
                    this.map.getTarget().style.cursor = hit ? 'pointer' : '';
                });
            }

            showSignalPopup(signal, coordinate) {
                const vessel = app.vesselDB.findByStationNumber(signal.stationNumber);
                const content = `
                    <div class="signal-popup">
                        <h4>${signal.isTest ? '✅ Тестовый сигнал' : '🚨 ТРЕВОГА'}</h4>
                        <p><strong>Стойка:</strong> ${signal.stationNumber}</p>
                        <p><strong>Судно:</strong> ${vessel ? vessel.name : 'Неизвестно'}</p>
                        <p><strong>MMSI:</strong> ${signal.mmsi || '-'}</p>
                        <p><strong>Время:</strong> ${formatDate(signal.receivedAt)}</p>
                        <p><strong>Координаты:</strong> ${signal.coordinates.lat.toFixed(4)}°, ${signal.coordinates.lon.toFixed(4)}°</p>
                        <div class="popup-actions">
                            <button onclick="viewSignalDetails('${signal.id}')">Подробнее</button>
                            ${!signal.isTest ? `<button onclick="sendToPoiskMore('${signal.id}')">В Поиск-Море</button>` : ''}
                        </div>
                    </div>
                `;
                
                this.popup.getElement().querySelector('.ol-popup-content').innerHTML = content;
                this.popup.setPosition(coordinate);
            }

            showClusterPopup(features, coordinate) {
                const signals = features.map(f => f.get('signal'));
                const content = `
                    <div class="cluster-popup">
                        <h4>Группа сигналов (${signals.length})</h4>
                        <div class="signal-list">
                            ${signals.slice(0, 5).map(signal => `
                                <div class="signal-item">
                                    ${signal.isTest ? '✅' : '🚨'} ${signal.stationNumber} - ${formatDate(signal.receivedAt)}
                                </div>
                            `).join('')}
                            ${signals.length > 5 ? `<p>и еще ${signals.length - 5}...</p>` : ''}
                        </div>
                        <button onclick="mapManager.zoomToCluster(${coordinate[0]}, ${coordinate[1]})">Приблизить</button>
                    </div>
                `;
                
                this.popup.getElement().querySelector('.ol-popup-content').innerHTML = content;
                this.popup.setPosition(coordinate);
            }

            zoomToSignals() {
                const extent = this.vectorSource.getExtent();
                if (!ol.extent.isEmpty(extent)) {
                    this.map.getView().fit(extent, {
                        padding: [50, 50, 50, 50],
                        duration: 1000
                    });
                }
            }

            zoomToCluster(x, y) {
                this.map.getView().animate({
                    center: [x, y],
                    zoom: this.map.getView().getZoom() + 2,
                    duration: 500
                });
            }

            measureDistance() {
                // Удаление предыдущих измерений
                if (this.drawInteraction) {
                    this.map.removeInteraction(this.drawInteraction);
                }

                const source = new ol.source.Vector();
                const vector = new ol.layer.Vector({
                    source: source,
                    style: new ol.style.Style({
                        fill: new ol.style.Fill({
                            color: 'rgba(255, 255, 255, 0.2)'
                        }),
                        stroke: new ol.style.Stroke({
                            color: '#ffcc33',
                            width: 2
                        })
                    })
                });

                this.map.addLayer(vector);

                this.drawInteraction = new ol.interaction.Draw({
                    source: source,
                    type: 'LineString'
                });

                this.drawInteraction.on('drawend', (evt) => {
                    const geometry = evt.feature.getGeometry();
                    const coordinates = geometry.getCoordinates();
                    
                    let distance = 0;
                    for (let i = 0; i < coordinates.length - 1; i++) {
                        const c1 = ol.proj.transform(coordinates[i], 'EPSG:3857', 'EPSG:4326');
                        const c2 = ol.proj.transform(coordinates[i + 1], 'EPSG:3857', 'EPSG:4326');
                        distance += this.calculateDistance(c1, c2);
                    }
                    
                    alert(`Расстояние: ${distance.toFixed(2)} морских миль`);
                    
                    this.map.removeInteraction(this.drawInteraction);
                    setTimeout(() => {
                        this.map.removeLayer(vector);
                    }, 3000);
                });

                this.map.addInteraction(this.drawInteraction);
            }

            calculateDistance(coord1, coord2) {
                const R = 3440.065; // Радиус Земли в морских милях
                const dLat = this.toRad(coord2[1] - coord1[1]);
                const dLon = this.toRad(coord2[0] - coord1[0]);
                const lat1 = this.toRad(coord1[1]);
                const lat2 = this.toRad(coord2[1]);

                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                        Math.sin(dLon/2) * Math.sin(dLon/2) * Math.cos(lat1) * Math.cos(lat2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                
                return R * c;
            }

            toRad(value) {
                return value * Math.PI / 180;
            }

            toggleHeatmap(show) {
                if (show && !this.heatmapLayer) {
                    this.heatmapLayer = new ol.layer.Heatmap({
                        source: this.vectorSource,
                        blur: 15,
                        radius: 8,
                        weight: (feature) => {
                            const signal = feature.get('signal');
                            return signal.isTest ? 0.5 : 1;
                        }
                    });
                    this.map.addLayer(this.heatmapLayer);
                } else if (!show && this.heatmapLayer) {
                    this.map.removeLayer(this.heatmapLayer);
                    this.heatmapLayer = null;
                }
            }

            exportMapImage() {
                this.map.once('rendercomplete', () => {
                    const mapCanvas = document.createElement('canvas');
                    const size = this.map.getSize();
                    mapCanvas.width = size[0];
                    mapCanvas.height = size[1];
                    const mapContext = mapCanvas.getContext('2d');
                    
                    Array.prototype.forEach.call(
                        document.querySelectorAll('.ol-layer canvas'),
                        (canvas) => {
                            if (canvas.width > 0) {
                                const opacity = canvas.parentNode.style.opacity;
                                mapContext.globalAlpha = opacity === '' ? 1 : Number(opacity);
                                const transform = canvas.style.transform;
                                const matrix = transform
                                    .match(/^matrix\(([^\(]*)\)$/)[1]
                                    .split(',')
                                    .map(Number);
                                CanvasRenderingContext2D.prototype.setTransform.apply(mapContext, matrix);
                                mapContext.drawImage(canvas, 0, 0);
                            }
                        }
                    );
                    
                    // Сохранение изображения
                    mapCanvas.toBlob((blob) => {
                        const url = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = url;
                        link.download = `map-${Date.now()}.png`;
                        link.click();
                        URL.revokeObjectURL(url);
                    });
                });
                
                this.map.renderSync();
            }

            clearMap() {
                if (confirm('Очистить все временные слои на карте?')) {
                    // Удаление временных слоев
                    const layersToRemove = [];
                    this.map.getLayers().forEach(layer => {
                        const name = layer.get('name');
                        if (!name || (name !== 'OSM' && name !== 'Satellite' && name !== 'SeaMarks' && name !== 'Signals')) {
                            layersToRemove.push(layer);
                        }
                    });
                    
                    layersToRemove.forEach(layer => {
                        this.map.removeLayer(layer);
                    });
                    
                    // Закрытие popup
                    this.popup.setPosition(undefined);
                }
            }
        }

        // ===== АВТОМАТИЧЕСКАЯ ОТПРАВКА ПОДТВЕРЖДЕНИЙ =====
        
        class EmailAutoSender {
            constructor() {
                this.emailQueue = [];
                this.smtp = {
                    host: localStorage.getItem('smtpHost') || 'smtp.gmail.com',
                    port: localStorage.getItem('smtpPort') || '587',
                    user: localStorage.getItem('smtpUser') || '',
                    pass: localStorage.getItem('smtpPass') || '',
                    from: localStorage.getItem('smtpFrom') || 'ssto@morflot.ru'
                };
                this.templates = this.loadTemplates();
            }

            loadTemplates() {
                return {
                    testConfirmation: {
                        subject: 'Подтверждение получения тестового сигнала ССТО',
                        body: `
ФГБУ «МОРСПАССЛУЖБА»
Главный морской спасательно-координационный центр

Подтверждаем получение тестового сигнала от системы ССТО

Детали теста:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Судно: {{vesselName}}
MMSI: {{mmsi}}
IMO: {{imo}}
Номер стойки ССТО: {{stationNumber}}
Тип системы: {{satcomType}}
Дата/время теста: {{testDate}}
Координаты: {{coordinates}}
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Результат: ✅ ТЕСТ УСПЕШНО ПРОЙДЕН

Сигнал получен и обработан в соответствии с установленными процедурами.

С уважением,
Оперативный дежурный ГМСКЦ
Тел: +7 (495) 626-10-52
Email: gmskc@morflot.ru

---
Это автоматическое сообщение. Пожалуйста, не отвечайте на него.
                        `
                    },
                    alertNotification: {
                        subject: '🚨 ТРЕВОГА ССТО - Требуется немедленное реагирование',
                        body: `
ВНИМАНИЕ! ПОЛУЧЕН СИГНАЛ ТРЕВОГИ ССТО

Судно: {{vesselName}}
MMSI: {{mmsi}}
Координаты: {{coordinates}}
Время: {{receivedAt}}

ТРЕБУЕТСЯ НЕМЕДЛЕННОЕ РЕАГИРОВАНИЕ!

Сигнал передан в систему Поиск-Море.
ID в системе: {{poiskMoreId}}
                        `
                    }
                };
            }

            async sendConfirmation(request, signal) {
                try {
                    // Получение данных судна
                    const vessel = app.vesselDB.findByStationNumber(signal.stationNumber);
                    if (!vessel || !vessel.email) {
                        throw new Error('Email судовладельца не найден');
                    }

                    // Подготовка данных для шаблона
                    const templateData = {
                        vesselName: vessel.name,
                        mmsi: vessel.mmsi,
                        imo: vessel.imo || 'Не указан',
                        stationNumber: signal.stationNumber,
                        satcomType: vessel.satcomType,
                        testDate: formatDate(signal.receivedAt),
                        coordinates: signal.coordinates 
                            ? `${signal.coordinates.lat.toFixed(4)}° с.ш., ${signal.coordinates.lon.toFixed(4)}° в.д.`
                            : 'Не указаны'
                    };

                    // Генерация письма из шаблона
                    const emailContent = this.processTemplate(
                        this.templates.testConfirmation.body,
                        templateData
                    );

                    // Создание PDF вложения
                    const pdfContent = await this.generatePDF(request, signal, vessel);

                    // Добавление в очередь отправки
                    const email = {
                        id: `EMAIL-${Date.now()}`,
                        to: vessel.email,
                        cc: 'gmskc@morflot.ru',
                        subject: this.templates.testConfirmation.subject,
                        body: emailContent,
                        attachments: [
                            {
                                filename: `SSTO_Test_${signal.stationNumber}_${Date.now()}.pdf`,
                                content: pdfContent,
                                contentType: 'application/pdf'
                            }
                        ],
                        createdAt: new Date().toISOString(),
                        status: 'pending'
                    };

                    this.emailQueue.push(email);
                    
                    // Попытка немедленной отправки
                    await this.processQueue();
                    
                    return {
                        success: true,
                        emailId: email.id,
                        message: `Подтверждение отправлено на ${vessel.email}`
                    };

                } catch (error) {
                    console.error('Ошибка отправки подтверждения:', error);
                    return {
                        success: false,
                        error: error.message
                    };
                }
            }

            processTemplate(template, data) {
                let result = template;
                for (const [key, value] of Object.entries(data)) {
                    const regex = new RegExp(`{{${key}}}`, 'g');
                    result = result.replace(regex, value);
                }
                return result;
            }

            async generatePDF(request, signal, vessel) {
                // Генерация HTML для PDF
                const html = `
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="UTF-8">
                    <style>
                        body { font-family: Arial, sans-serif; }
                        .header { background: #001f3f; color: white; padding: 20px; }
                        .content { padding: 20px; }
                        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
                        th, td { border: 1px solid #ddd; padding: 10px; text-align: left; }
                        th { background: #f0f0f0; }
                        .success { color: green; font-weight: bold; }
                        .signature { margin-top: 50px; border-top: 1px solid #000; width: 300px; }
                    </style>
                </head>
                <body>
                    <div class="header">
                        <h1>ФГБУ «МОРСПАССЛУЖБА»</h1>
                        <h2>Главный морской спасательно-координационный центр</h2>
                    </div>
                    <div class="content">
                        <h3>ПОДТВЕРЖДЕНИЕ ПОЛУЧЕНИЯ ТЕСТОВОГО СИГНАЛА ССТО</h3>
                        <p>Дата: ${new Date().toLocaleDateString('ru-RU')}</p>
                        <p>Номер: ${request.id}</p>
                        
                        <table>
                            <tr><th>Параметр</th><th>Значение</th></tr>
                            <tr><td>Судно</td><td>${vessel.name}</td></tr>
                            <tr><td>MMSI</td><td>${vessel.mmsi}</td></tr>
                            <tr><td>IMO</td><td>${vessel.imo || 'Не указан'}</td></tr>
                            <tr><td>Позывной</td><td>${vessel.callSign || 'Не указан'}</td></tr>
                            <tr><td>Номер стойки ССТО</td><td><strong>${signal.stationNumber}</strong></td></tr>
                            <tr><td>Тип системы</td><td>${vessel.satcomType}</td></tr>
                            <tr><td>Дата/время теста</td><td>${formatDate(signal.receivedAt)}</td></tr>
                            <tr><td>Координаты</td><td>${signal.coordinates ? 
                                `${signal.coordinates.lat.toFixed(4)}° с.ш., ${signal.coordinates.lon.toFixed(4)}° в.д.` : 
                                'Не переданы'}</td></tr>
                            <tr><td>Результат</td><td class="success">ТЕСТ ПРОЙДЕН УСПЕШНО</td></tr>
                        </table>
                        
                        <p>Тестовый сигнал получен и обработан в соответствии с установленными процедурами.</p>
                        <p>Система ССТО судна функционирует в штатном режиме.</p>
                        
                        <div class="signature">
                            <p>Оперативный дежурный ГМСКЦ</p>
                            <p>_____________________</p>
                            <p>${new Date().toLocaleString('ru-RU')}</p>
                        </div>
                    </div>
                </body>
                </html>
                `;
                
                // В реальной системе здесь должна быть генерация PDF
                // Для демо возвращаем base64 строку
                return btoa(unescape(encodeURIComponent(html)));
            }

            async processQueue() {
                const pending = this.emailQueue.filter(e => e.status === 'pending');
                
                for (const email of pending) {
                    try {
                        // В реальной системе здесь должна быть отправка через SMTP
                        // Для демо имитируем отправку
                        await this.simulateSend(email);
                        
                        email.status = 'sent';
                        email.sentAt = new Date().toISOString();
                        
                        console.log(`✅ Email ${email.id} отправлен на ${email.to}`);
                        
                    } catch (error) {
                        email.status = 'failed';
                        email.error = error.message;
                        console.error(`❌ Ошибка отправки ${email.id}:`, error);
                    }
                }
                
                // Сохранение очереди
                localStorage.setItem('emailQueue', JSON.stringify(this.emailQueue));
            }

            async simulateSend(email) {
                // Имитация задержки отправки
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Имитация случайных ошибок (10% вероятность)
                if (Math.random() < 0.1) {
                    throw new Error('Сервер SMTP временно недоступен');
                }
                
                return true;
            }

            configureSMTP() {
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.innerHTML = `
                    <div class="modal-content">
                        <h3>Настройка SMTP</h3>
                        <form id="smtp-config-form">
                            <label>SMTP сервер:
                                <input type="text" id="smtp-host" value="${this.smtp.host}" required>
                            </label>
                            <label>Порт:
                                <input type="text" id="smtp-port" value="${this.smtp.port}" required>
                            </label>
                            <label>Пользователь:
                                <input type="text" id="smtp-user" value="${this.smtp.user}" required>
                            </label>
                            <label>Пароль:
                                <input type="password" id="smtp-pass" value="${this.smtp.pass}" required>
                            </label>
                            <label>От кого:
                                <input type="email" id="smtp-from" value="${this.smtp.from}" required>
                            </label>
                            <button type="submit">Сохранить</button>
                            <button type="button" onclick="this.parentElement.parentElement.remove()">Отмена</button>
                        </form>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                document.getElementById('smtp-config-form').onsubmit = (e) => {
                    e.preventDefault();
                    
                    this.smtp.host = document.getElementById('smtp-host').value;
                    this.smtp.port = document.getElementById('smtp-port').value;
                    this.smtp.user = document.getElementById('smtp-user').value;
                    this.smtp.pass = document.getElementById('smtp-pass').value;
                    this.smtp.from = document.getElementById('smtp-from').value;
                    
                    // Сохранение в localStorage
                    localStorage.setItem('smtpHost', this.smtp.host);
                    localStorage.setItem('smtpPort', this.smtp.port);
                    localStorage.setItem('smtpUser', this.smtp.user);
                    localStorage.setItem('smtpPass', this.smtp.pass);
                    localStorage.setItem('smtpFrom', this.smtp.from);
                    
                    showNotification('Настройки SMTP сохранены', 'success');
                    modal.remove();
                };
            }
        }

        // ===== ЗАГРУЗКА ДАННЫХ ИЗ EXCEL =====
        
        class ExcelDataLoader {
            constructor() {
                this.reader = new FileReader();
                this.setupHandlers();
            }

            setupHandlers() {
                // Создание скрытого input для загрузки файлов
                const input = document.createElement('input');
                input.type = 'file';
                input.id = 'excel-upload';
                input.accept = '.xlsx,.xls,.csv';
                input.style.display = 'none';
                document.body.appendChild(input);

                input.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        this.loadExcelFile(file);
                    }
                });
            }

            async loadExcelFile(file) {
                showNotification('Загрузка файла...', 'info');

                try {
                    const data = await this.readFile(file);
                    const workbook = XLSX.read(data, { type: 'binary' });
                    
                    // Определение типа данных по названиям листов
                    const sheetNames = workbook.SheetNames;
                    
                    let loadedData = {
                        vessels: [],
                        requests: [],
                        signals: []
                    };

                    sheetNames.forEach(sheetName => {
                        const worksheet = workbook.Sheets[sheetName];
                        const jsonData = XLSX.utils.sheet_to_json(worksheet);
                        
                        // Определение типа данных по названию листа или содержимому
                        if (sheetName.toLowerCase().includes('vessel') || 
                            sheetName.toLowerCase().includes('судн')) {
                            loadedData.vessels = this.parseVessels(jsonData);
                        } else if (sheetName.toLowerCase().includes('request') || 
                                  sheetName.toLowerCase().includes('заявк')) {
                            loadedData.requests = this.parseRequests(jsonData);
                        } else if (sheetName.toLowerCase().includes('signal') || 
                                  sheetName.toLowerCase().includes('сигнал')) {
                            loadedData.signals = this.parseSignals(jsonData);
                        } else {
                            // Попытка автоопределения по структуре данных
                            this.autoDetectAndParse(jsonData, loadedData);
                        }
                    });

                    // Импорт данных в систему
                    const result = await this.importData(loadedData);
                    
                    // Показ результатов
                    this.showImportResults(result);

                } catch (error) {
                    console.error('Ошибка загрузки Excel:', error);
                    showNotification(`Ошибка: ${error.message}`, 'error');
                }
            }

            readFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    
                    reader.onload = (e) => {
                        resolve(e.target.result);
                    };
                    
                    reader.onerror = (e) => {
                        reject(new Error('Ошибка чтения файла'));
                    };
                    
                    reader.readAsBinaryString(file);
                });
            }

            parseVessels(data) {
                return data.map(row => {
                    // Маппинг полей из Excel в формат системы
                    return {
                        name: row['Название судна'] || row['Vessel Name'] || row['Name'],
                        mmsi: String(row['MMSI'] || row['ММСи'] || ''),
                        imo: String(row['IMO'] || row['ИМО'] || ''),
                        callSign: row['Позывной'] || row['Call Sign'] || '',
                        flag: row['Флаг'] || row['Flag'] || 'RU',
                        type: row['Тип'] || row['Type'] || '',
                        stationNumbers: this.parseStationNumbers(
                            row['Номера стоек'] || row['Station Numbers'] || row['Номер стойки']
                        ),
                        owner: row['Судовладелец'] || row['Owner'] || '',
                        operator: row['Оператор'] || row['Operator'] || '',
                        email: row['Email'] || row['Электронная почта'] || '',
                        satcomType: row['Тип связи'] || row['SATCOM'] || 'INMARSAT',
                        status: row['Статус'] || row['Status'] || 'ACTIVE'
                    };
                }).filter(vessel => vessel.mmsi && vessel.stationNumbers.length > 0);
            }

            parseRequests(data) {
                return data.map(row => {
                    const testDate = this.parseDate(row['Дата теста'] || row['Test Date']);
                    
                    return {
                        id: row['ID'] || `IMP-REQ-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                        stationNumber: String(row['Номер стойки'] || row['Station Number'] || ''),
                        vesselName: row['Судно'] || row['Vessel'] || '',
                        mmsi: String(row['MMSI'] || ''),
                        imo: String(row['IMO'] || ''),
                        shipOwner: row['Судовладелец'] || row['Owner'] || '',
                        email: row['Email'] || '',
                        testDate: testDate,
                        satcomType: row['Тип'] || row['Type'] || 'INMARSAT',
                        status: this.parseStatus(row['Статус'] || row['Status']),
                        createdAt: this.parseDate(row['Создано'] || row['Created']) || new Date().toISOString(),
                        operator: row['Оператор'] || row['Operator'] || 'IMPORT'
                    };
                }).filter(request => request.stationNumber && request.mmsi);
            }

            parseSignals(data) {
                return data.map(row => {
                    const coords = this.parseCoordinates(
                        row['Широта'] || row['Lat'] || row['Latitude'],
                        row['Долгота'] || row['Lon'] || row['Longitude']
                    );
                    
                    return {
                        id: row['ID'] || `IMP-SIG-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                        stationNumber: String(row['Номер стойки'] || row['Station Number'] || ''),
                        mmsi: String(row['MMSI'] || ''),
                        type: row['Тип системы'] || row['System Type'] || 'INMARSAT',
                        coordinates: coords,
                        receivedAt: this.parseDate(row['Получен'] || row['Received']) || new Date().toISOString(),
                        isTest: this.parseBoolean(row['Тест'] || row['Test'] || row['Is Test']),
                        status: row['Статус'] || row['Status'] || 'RECEIVED'
                    };
                }).filter(signal => signal.stationNumber);
            }

            parseStationNumbers(value) {
                if (!value) return [];
                
                // Обработка различных форматов
                if (typeof value === 'string') {
                    // Разделители: запятая, точка с запятой, пробел
                    return value.split(/[,;:\s]+/)
                        .map(s => s.trim())
                        .filter(s => /^\d{9}$/.test(s));
                } else if (Array.isArray(value)) {
                    return value.map(s => String(s).trim())
                        .filter(s => /^\d{9}$/.test(s));
                } else {
                    return [String(value).trim()]
                        .filter(s => /^\d{9}$/.test(s));
                }
            }

            parseDate(value) {
                if (!value) return null;
                
                // Попытка парсинга различных форматов дат
                const date = new Date(value);
                
                if (isNaN(date.getTime())) {
                    // Попытка парсинга российского формата ДД.ММ.ГГГГ
                    const parts = value.split(/[.\-\/]/);
                    if (parts.length === 3) {
                        const day = parseInt(parts[0]);
                        const month = parseInt(parts[1]) - 1;
                        const year = parseInt(parts[2]);
                        
                        if (year > 1900 && year < 2100) {
                            return new Date(year, month, day).toISOString();
                        }
                    }
                    return null;
                }
                
                return date.toISOString();
            }

            parseCoordinates(lat, lon) {
                if (!lat || !lon) return null;
                
                const latitude = parseFloat(lat);
                const longitude = parseFloat(lon);
                
                if (isNaN(latitude) || isNaN(longitude)) return null;
                
                return {
                    lat: latitude,
                    lon: longitude
                };
            }

            parseStatus(value) {
                if (!value) return 'pending';
                
                const status = value.toLowerCase();
                if (status.includes('подтвержд') || status.includes('confirm')) {
                    return 'confirmed';
                } else if (status.includes('отмен') || status.includes('cancel')) {
                    return 'cancelled';
                } else if (status.includes('истек') || status.includes('expir')) {
                    return 'expired';
                }
                
                return 'pending';
            }

            parseBoolean(value) {
                if (typeof value === 'boolean') return value;
                if (typeof value === 'number') return value > 0;
                if (typeof value === 'string') {
                    const str = value.toLowerCase();
                    return str === 'да' || str === 'yes' || str === 'true' || str === '1';
                }
                return false;
            }

            autoDetectAndParse(data, loadedData) {
                if (data.length === 0) return;
                
                const firstRow = data[0];
                const keys = Object.keys(firstRow);
                
                // Определение по ключевым полям
                if (keys.some(k => k.toLowerCase().includes('vessel') || k.toLowerCase().includes('судн'))) {
                    loadedData.vessels = this.parseVessels(data);
                } else if (keys.some(k => k.toLowerCase().includes('request') || k.toLowerCase().includes('заявк'))) {
                    loadedData.requests = this.parseRequests(data);
                } else if (keys.some(k => k.toLowerCase().includes('signal') || k.toLowerCase().includes('сигнал'))) {
                    loadedData.signals = this.parseSignals(data);
                }
            }

            async importData(loadedData) {
                const result = {
                    vessels: { imported: 0, skipped: 0, errors: [] },
                    requests: { imported: 0, skipped: 0, errors: [] },
                    signals: { imported: 0, skipped: 0, errors: [] }
                };

                // Импорт судов
                for (const vessel of loadedData.vessels) {
                    try {
                        app.vesselDB.addVessel(vessel);
                        result.vessels.imported++;
                    } catch (error) {
                        result.vessels.skipped++;
                        result.vessels.errors.push({
                            vessel: vessel.name,
                            error: error.message
                        });
                    }
                }

                // Импорт заявок
                const existingRequests = JSON.parse(localStorage.getItem('testRequests') || '[]');
                const newRequests = [];
                
                for (const request of loadedData.requests) {
                    if (!existingRequests.find(r => r.id === request.id)) {
                        newRequests.push(request);
                        result.requests.imported++;
                    } else {
                        result.requests.skipped++;
                    }
                }
                
                if (newRequests.length > 0) {
                    localStorage.setItem('testRequests', 
                        JSON.stringify([...existingRequests, ...newRequests]));
                }

                // Импорт сигналов
                const existingSignals = JSON.parse(localStorage.getItem('signals') || '[]');
                const newSignals = [];
                
                for (const signal of loadedData.signals) {
                    if (!existingSignals.find(s => s.id === signal.id)) {
                        newSignals.push(signal);
                        result.signals.imported++;
                    } else {
                        result.signals.skipped++;
                    }
                }
                
                if (newSignals.length > 0) {
                    localStorage.setItem('signals', 
                        JSON.stringify([...existingSignals, ...newSignals]));
                }

                // Обновление интерфейса
                loadRequests();
                loadSignals();
                loadTerminals();
                loadDashboardData();
                
                if (window.mapManager) {
                    window.mapManager.loadSignalsToMap();
                }

                return result;
            }

            showImportResults(result) {
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.innerHTML = `
                    <div class="modal-content">
                        <h3>Результаты импорта данных</h3>
                        
                        <h4>Суда</h4>
                        <p>✅ Импортировано: ${result.vessels.imported}</p>
                        <p>⏭️ Пропущено: ${result.vessels.skipped}</p>
                        ${result.vessels.errors.length > 0 ? `
                            <details>
                                <summary>❌ Ошибки (${result.vessels.errors.length})</summary>
                                <ul>
                                    ${result.vessels.errors.map(e => 
                                        `<li>${e.vessel}: ${e.error}</li>`
                                    ).join('')}
                                </ul>
                            </details>
                        ` : ''}
                        
                        <h4>Заявки</h4>
                        <p>✅ Импортировано: ${result.requests.imported}</p>
                        <p>⏭️ Пропущено: ${result.requests.skipped}</p>
                        
                        <h4>Сигналы</h4>
                        <p>✅ Импортировано: ${result.signals.imported}</p>
                        <p>⏭️ Пропущено: ${result.signals.skipped}</p>
                        
                        <button onclick="this.parentElement.parentElement.remove()">Закрыть</button>
                    </div>
                `;
                
                document.body.appendChild(modal);
            }

            openFileDialog() {
                document.getElementById('excel-upload').click();
            }
        }

        // ===== ИНИЦИАЛИЗАЦИЯ РАСШИРЕННЫХ ФУНКЦИЙ =====
        
        // Создание глобальных экземпляров
        window.mapManager = new AdvancedMapManager();
        window.emailSender = new EmailAutoSender();
        window.excelLoader = new ExcelDataLoader();

        // Добавление кнопок в интерфейс
        document.addEventListener('DOMContentLoaded', () => {
            // Кнопка загрузки Excel
            const toolbar = document.querySelector('.header-actions');
            if (toolbar) {
                const excelButton = document.createElement('button');
                excelButton.className = 'btn btn-primary';
                excelButton.innerHTML = '📊 Загрузить Excel';
                excelButton.onclick = () => window.excelLoader.openFileDialog();
                toolbar.appendChild(excelButton);

                const smtpButton = document.createElement('button');
                smtpButton.className = 'btn btn-secondary';
                smtpButton.innerHTML = '✉️ Настройки Email';
                smtpButton.onclick = () => window.emailSender.configureSMTP();
                toolbar.appendChild(smtpButton);
            }

            // Инициализация расширенной карты
            if (document.getElementById('map')) {
                window.mapManager.initAdvancedMap();
            }
        });

        // Расширение функции автоподтверждения
        const originalProcessSignal = AutoConfirmationManager.prototype.processSignal;
        AutoConfirmationManager.prototype.processSignal = function(signal) {
            const result = originalProcessSignal.call(this, signal);
            
            if (result.processed) {
                // Автоматическая отправка email
                const request = JSON.parse(localStorage.getItem('testRequests') || '[]')
                    .find(r => r.id === result.requestId);
                    
                if (request) {
                    window.emailSender.sendConfirmation(request, signal);
                }
            }
            
            return result;
        };

<!-- КОНЕЦ РАСШИРЕННЫХ ФУНКЦИЙ -->
        // ===== ИНИЦИАЛИЗАЦИЯ ПРИ ЗАГРУЗКЕ СТРАНИЦЫ =====
        
        document.addEventListener('DOMContentLoaded', () => {
            console.log('📄 DOM загружен, инициализация системы...');
            
            try {
                // Основная инициализация
                initializeApp();
                
                // Дополнительные настройки
                setupHotkeys();
                initNotifications();
                
                // Проверка системы
                const healthCheck = systemHealthCheck();
                console.log('🏥 Проверка системы:', healthCheck);
                
                // Логирование запуска
                logEvent('SYSTEM_START', {
                    version: getSystemVersion(),
                    healthCheck: healthCheck
                });
                
                // Запуск периодических проверок
                setInterval(checkForNewSignals, 60000); // каждую минуту
                setInterval(processEmailQueue, 120000); // каждые 2 минуты
                
                // Показ версии в консоли
                const version = getSystemVersion();
                console.log(`%c${version.name} v${version.version}`, 
                           'color: #667eea; font-size: 20px; font-weight: bold;');
                console.log(`Build: ${version.build}`);
                console.log('© 2025 ГАМЦ Росморречфлот');
                
            } catch (error) {
                console.error('❌ Ошибка инициализации:', error);
                showNotification('Ошибка инициализации системы', 'error');
            }
        });

        // Обработка закрытия страницы
        window.addEventListener('beforeunload', (e) => {
            // Логирование завершения работы
            logEvent('SYSTEM_STOP', {
                statistics: getUsageStatistics()
            });
            
            // Проверка несохраненных данных
            const pendingRequests = JSON.parse(localStorage.getItem('testRequests') || '[]')
                .filter(r => r.status === 'pending');
            
            if (pendingRequests.length > 0) {
                e.preventDefault();
                e.returnValue = 'Есть необработанные заявки. Вы уверены, что хотите выйти?';
            }
        });

        // Обработка ошибок
        window.addEventListener('error', (e) => {
            console.error('❌ Глобальная ошибка:', e.error);
            logEvent('SYSTEM_ERROR', {
                message: e.message,
                filename: e.filename,
                lineno: e.lineno,
                colno: e.colno
            });
        });

        console.log('✅ Скрипт модуля ТЕСТ ССТО полностью загружен');
        
    </script>
</body>
</html>
<!-- ===== КОНЕЦ ФАЙЛА index.html ===== -->
<!-- Модуль ТЕСТ ССТО v1.0.0 -->
<!-- © 2025 ГАМЦ Росморречфлот -->
<!-- Всего строк кода: ~3800 -->