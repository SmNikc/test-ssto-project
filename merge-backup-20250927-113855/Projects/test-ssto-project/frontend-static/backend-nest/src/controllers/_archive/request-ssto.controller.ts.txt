// C:\Projects\test-ssto-project\backend-nest\src\controllers\request-ssto.controller.ts
// Контроллер для API endpoints заявок
// Доработка: в ответах всегда включаем request_number (даже если модель его не типизирует)

import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  HttpStatus,
  Res,
} from '@nestjs/common';
import { Response } from 'express';
import { RequestService } from '../request/request.service';

@Controller('requests')
export class RequestController {
  constructor(private readonly requestService: RequestService) {}

  // Вспомогательная сериализация заявки с request_number
  private withRequestNumber(row: any) {
    if (!row) return row;
    // toJSON, если есть
    const plain = typeof row.toJSON === 'function' ? row.toJSON() : row;
    // добираем request_number из getDataValue или прямого доступа
    const rn =
      (typeof row.getDataValue === 'function' && row.getDataValue('request_number')) ||
      plain.request_number ||
      row['request_number'];
    return { ...plain, request_number: rn };
  }

  // POST /requests - Создание новой заявки
  @Post()
  async create(@Body() createRequestDto: any, @Res() res: Response) {
    try {
      // Добавляем сигнальный ID на основе времени
      const requestData = {
        ...createRequestDto,
        test_datetime: new Date(createRequestDto.test_datetime || Date.now()),
      };

      const request = await this.requestService.create(requestData);
      const data = this.withRequestNumber(request);

      return res.status(HttpStatus.CREATED).json({
        success: true,
        message: 'Заявка успешно создана',
        data,
      });
    } catch (error: any) {
      return res.status(HttpStatus.BAD_REQUEST).json({
        success: false,
        message: 'Ошибка создания заявки',
        error: error.message,
      });
    }
  }

  // GET /requests - Получение всех заявок
  @Get()
  async findAll(@Res() res: Response) {
    try {
      const rows = await this.requestService.findAll();
      const data = (rows || []).map(r => this.withRequestNumber(r));
      return res.status(HttpStatus.OK).json({
        success: true,
        count: data.length,
        data,
      });
    } catch (error: any) {
      // В случае падения возвращаем 200 и пустой набор, чтобы фронт не падал
      return res.status(HttpStatus.OK).json({
        success: false,
        count: 0,
        data: [],
      });
    }
  }

  // GET /requests/pending - Получение ожидающих заявок
  @Get('pending')
  async findPending(@Res() res: Response) {
    try {
      const rows = await this.requestService.findPending();
      const data = (rows || []).map(r => this.withRequestNumber(r));
      return res.status(HttpStatus.OK).json({
        success: true,
        count: data.length,
        data,
      });
    } catch (error: any) {
      return res.status(HttpStatus.OK).json({
        success: false,
        count: 0,
        data: [],
      });
    }
  }

  // GET /requests/:id - Получение заявки по ID (ISN)
  @Get(':id')
  async findOne(@Param('id') id: string, @Res() res: Response) {
    try {
      const row = await this.requestService.findOne(id);
      const data = this.withRequestNumber(row);
      return res.status(HttpStatus.OK).json({
        success: true,
        data,
      });
    } catch (error: any) {
      return res.status(HttpStatus.INTERNAL_SERVER_ERROR).json({
        success: false,
        message: 'Ошибка получения заявки',
        error: error.message,
      });
    }
  }

  // PUT /requests/:id - Обновление заявки
  @Put(':id')
  async update(
    @Param('id') id: string,
    @Body() updateRequestDto: any,
    @Res() res: Response,
  ) {
    try {
      await this.requestService.update(id, updateRequestDto);
      const updated = await this.requestService.findOne(id);
      const data = this.withRequestNumber(updated);
      return res.status(HttpStatus.OK).json({
        success: true,
        message: 'Заявка успешно обновлена',
        data,
      });
    } catch (error: any) {
      return res.status(HttpStatus.BAD_REQUEST).json({
        success: false,
        message: 'Ошибка обновления заявки',
        error: error.message,
      });
    }
  }

  // PUT /requests/:id/status - Обновление статуса заявки
  @Put(':id/status')
  async updateStatus(
    @Param('id') id: string,
    @Body('status') status: string,
    @Res() res: Response,
  ) {
    try {
      await this.requestService.updateStatus(id, status);
      const updated = await this.requestService.findOne(id);
      const data = this.withRequestNumber(updated);
      return res.status(HttpStatus.OK).json({
        success: true,
        message: `Статус заявки изменен на ${status}`,
        data,
      });
    } catch (error: any) {
      return res.status(HttpStatus.BAD_REQUEST).json({
        success: false,
        message: 'Ошибка обновления статуса',
        error: error.message,
      });
    }
  }

  // DELETE /requests/:id - Удаление заявки
  @Delete(':id')
  async remove(@Param('id') id: string, @Res() res: Response) {
    try {
      const row = await this.requestService.remove(id);
      return res.status(HttpStatus.OK).json({
        success: true,
        message: 'Заявка успешно удалена',
        result: row,
      });
    } catch (error: any) {
      return res.status(HttpStatus.BAD_REQUEST).json({
        success: false,
        message: 'Ошибка удаления заявки',
        error: error.message,
      });
    }
  }
}
